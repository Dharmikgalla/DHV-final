"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/cluster/route";
exports.ids = ["app/api/cluster/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcluster%2Froute&page=%2Fapi%2Fcluster%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcluster%2Froute.ts&appDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcluster%2Froute&page=%2Fapi%2Fcluster%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcluster%2Froute.ts&appDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_SANJAY_Downloads_Dharmik_DHV_DHV_project_2_app_api_cluster_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/cluster/route.ts */ \"(rsc)/./app/api/cluster/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/cluster/route\",\n        pathname: \"/api/cluster\",\n        filename: \"route\",\n        bundlePath: \"app/api/cluster/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\SANJAY\\\\Downloads\\\\Dharmik\\\\DHV\\\\DHV-project-2\\\\app\\\\api\\\\cluster\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_SANJAY_Downloads_Dharmik_DHV_DHV_project_2_app_api_cluster_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/cluster/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZjbHVzdGVyJTJGcm91dGUmcGFnZT0lMkZhcGklMkZjbHVzdGVyJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY2x1c3RlciUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNTQU5KQVklNUNEb3dubG9hZHMlNUNEaGFybWlrJTVDREhWJTVDREhWLXByb2plY3QtMiU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9QyUzQSU1Q1VzZXJzJTVDU0FOSkFZJTVDRG93bmxvYWRzJTVDRGhhcm1payU1Q0RIViU1Q0RIVi1wcm9qZWN0LTImaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ3NDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGllcmFyY2hpY2FsLWNsdXN0ZXJpbmctdmlzdWFsaXphdGlvbi8/ZTE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxTQU5KQVlcXFxcRG93bmxvYWRzXFxcXERoYXJtaWtcXFxcREhWXFxcXERIVi1wcm9qZWN0LTJcXFxcYXBwXFxcXGFwaVxcXFxjbHVzdGVyXFxcXHJvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jbHVzdGVyL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvY2x1c3RlclwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvY2x1c3Rlci9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIkM6XFxcXFVzZXJzXFxcXFNBTkpBWVxcXFxEb3dubG9hZHNcXFxcRGhhcm1pa1xcXFxESFZcXFxcREhWLXByb2plY3QtMlxcXFxhcHBcXFxcYXBpXFxcXGNsdXN0ZXJcXFxccm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2NsdXN0ZXIvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcluster%2Froute&page=%2Fapi%2Fcluster%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcluster%2Froute.ts&appDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/cluster/route.ts":
/*!**********************************!*\
  !*** ./app/api/cluster/route.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _shared_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/schema */ \"(rsc)/./shared/schema.ts\");\n/* harmony import */ var _lib_clustering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/clustering */ \"(rsc)/./app/lib/clustering.ts\");\n\n\n\nasync function POST(req) {\n    try {\n        const body = await req.json();\n        const { algorithm, dataPoints } = _shared_schema__WEBPACK_IMPORTED_MODULE_1__.clusterRequestSchema.parse(body);\n        const points = dataPoints.map((dp, idx)=>({\n                id: dp.data?.Patient_ID || dp.data?.Crime_ID || dp.data?.Customer_ID || `Point${idx}`,\n                x: dp.x,\n                y: dp.y,\n                data: dp.data\n            }));\n        const result = algorithm === \"agglomerative\" ? (0,_lib_clustering__WEBPACK_IMPORTED_MODULE_2__.agglomerativeClustering)(points) : (0,_lib_clustering__WEBPACK_IMPORTED_MODULE_2__.divisiveClustering)(points);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            steps: result.steps,\n            finalClusters: result.finalClusters,\n            dendrogram: result.dendrogram\n        });\n    } catch (error) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error?.message || \"Failed to perform clustering\"\n        }, {\n            status: 400\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2NsdXN0ZXIvcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RDtBQUNGO0FBQzZCO0FBRTVFLGVBQWVJLEtBQUtDLEdBQWdCO0lBQ3pDLElBQUk7UUFDRixNQUFNQyxPQUFPLE1BQU1ELElBQUlFLElBQUk7UUFDM0IsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRSxHQUFHUixnRUFBb0JBLENBQUNTLEtBQUssQ0FBQ0o7UUFFN0QsTUFBTUssU0FBU0YsV0FBV0csR0FBRyxDQUFDLENBQUNDLElBQVNDLE1BQWlCO2dCQUN2REMsSUFBSUYsR0FBR0csSUFBSSxFQUFFQyxjQUFjSixHQUFHRyxJQUFJLEVBQUVFLFlBQVlMLEdBQUdHLElBQUksRUFBRUcsZUFBZSxDQUFDLEtBQUssRUFBRUwsSUFBSSxDQUFDO2dCQUNyRk0sR0FBR1AsR0FBR08sQ0FBQztnQkFDUEMsR0FBR1IsR0FBR1EsQ0FBQztnQkFDUEwsTUFBTUgsR0FBR0csSUFBSTtZQUNmO1FBRUEsTUFBTU0sU0FBU2QsY0FBYyxrQkFDekJOLHdFQUF1QkEsQ0FBQ1MsVUFDeEJSLG1FQUFrQkEsQ0FBQ1E7UUFFdkIsT0FBT1gscURBQVlBLENBQUNPLElBQUksQ0FBQztZQUN2QmdCLFNBQVM7WUFDVEMsT0FBT0YsT0FBT0UsS0FBSztZQUNuQkMsZUFBZUgsT0FBT0csYUFBYTtZQUNuQ0MsWUFBWUosT0FBT0ksVUFBVTtRQUMvQjtJQUNGLEVBQUUsT0FBT0MsT0FBWTtRQUNuQixPQUFPM0IscURBQVlBLENBQUNPLElBQUksQ0FDdEI7WUFBRWdCLFNBQVM7WUFBT0ksT0FBT0EsT0FBT0MsV0FBVztRQUErQixHQUMxRTtZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2hpZXJhcmNoaWNhbC1jbHVzdGVyaW5nLXZpc3VhbGl6YXRpb24vLi9hcHAvYXBpL2NsdXN0ZXIvcm91dGUudHM/MzNmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCI7XHJcbmltcG9ydCB7IGNsdXN0ZXJSZXF1ZXN0U2NoZW1hIH0gZnJvbSBcIkBzaGFyZWQvc2NoZW1hXCI7XHJcbmltcG9ydCB7IGFnZ2xvbWVyYXRpdmVDbHVzdGVyaW5nLCBkaXZpc2l2ZUNsdXN0ZXJpbmcgfSBmcm9tIFwiLi4vLi4vbGliL2NsdXN0ZXJpbmdcIjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcTogTmV4dFJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcS5qc29uKCk7XHJcbiAgICBjb25zdCB7IGFsZ29yaXRobSwgZGF0YVBvaW50cyB9ID0gY2x1c3RlclJlcXVlc3RTY2hlbWEucGFyc2UoYm9keSk7XHJcblxyXG4gICAgY29uc3QgcG9pbnRzID0gZGF0YVBvaW50cy5tYXAoKGRwOiBhbnksIGlkeDogbnVtYmVyKSA9PiAoe1xyXG4gICAgICBpZDogZHAuZGF0YT8uUGF0aWVudF9JRCB8fCBkcC5kYXRhPy5DcmltZV9JRCB8fCBkcC5kYXRhPy5DdXN0b21lcl9JRCB8fCBgUG9pbnQke2lkeH1gLFxyXG4gICAgICB4OiBkcC54LFxyXG4gICAgICB5OiBkcC55LFxyXG4gICAgICBkYXRhOiBkcC5kYXRhLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IGFsZ29yaXRobSA9PT0gXCJhZ2dsb21lcmF0aXZlXCJcclxuICAgICAgPyBhZ2dsb21lcmF0aXZlQ2x1c3RlcmluZyhwb2ludHMpXHJcbiAgICAgIDogZGl2aXNpdmVDbHVzdGVyaW5nKHBvaW50cyk7XHJcblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgc3RlcHM6IHJlc3VsdC5zdGVwcyxcclxuICAgICAgZmluYWxDbHVzdGVyczogcmVzdWx0LmZpbmFsQ2x1c3RlcnMsXHJcbiAgICAgIGRlbmRyb2dyYW06IHJlc3VsdC5kZW5kcm9ncmFtLFxyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3I/Lm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gcGVyZm9ybSBjbHVzdGVyaW5nXCIgfSxcclxuICAgICAgeyBzdGF0dXM6IDQwMCB9LFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJjbHVzdGVyUmVxdWVzdFNjaGVtYSIsImFnZ2xvbWVyYXRpdmVDbHVzdGVyaW5nIiwiZGl2aXNpdmVDbHVzdGVyaW5nIiwiUE9TVCIsInJlcSIsImJvZHkiLCJqc29uIiwiYWxnb3JpdGhtIiwiZGF0YVBvaW50cyIsInBhcnNlIiwicG9pbnRzIiwibWFwIiwiZHAiLCJpZHgiLCJpZCIsImRhdGEiLCJQYXRpZW50X0lEIiwiQ3JpbWVfSUQiLCJDdXN0b21lcl9JRCIsIngiLCJ5IiwicmVzdWx0Iiwic3VjY2VzcyIsInN0ZXBzIiwiZmluYWxDbHVzdGVycyIsImRlbmRyb2dyYW0iLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/cluster/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/lib/clustering.ts":
/*!*******************************!*\
  !*** ./app/lib/clustering.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   agglomerativeClustering: () => (/* binding */ agglomerativeClustering),\n/* harmony export */   divisiveClustering: () => (/* binding */ divisiveClustering),\n/* harmony export */   euclideanDistance: () => (/* binding */ euclideanDistance)\n/* harmony export */ });\n// Calculate Euclidean distance between two points\nfunction euclideanDistance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n}\n// Calculate distance between two clusters (average linkage)\nfunction clusterDistance(c1, c2, points) {\n    let totalDistance = 0;\n    let count = 0;\n    for (const i of c1.points){\n        for (const j of c2.points){\n            if (points[i] && points[j]) {\n                totalDistance += euclideanDistance(points[i], points[j]);\n                count++;\n            }\n        }\n    }\n    return count > 0 ? totalDistance / count : Infinity;\n}\n// Get cluster center\nfunction getClusterCenter(cluster, points) {\n    let sumX = 0;\n    let sumY = 0;\n    let count = 0;\n    for (const idx of cluster.points){\n        if (points[idx]) {\n            sumX += points[idx].x;\n            sumY += points[idx].y;\n            count++;\n        }\n    }\n    return count > 0 ? {\n        x: sumX / count,\n        y: sumY / count\n    } : {\n        x: 0,\n        y: 0\n    };\n}\n// Agglomerative (Bottom-Up) Hierarchical Clustering\nfunction agglomerativeClustering(points) {\n    const steps = [];\n    // Initialize: each point is its own cluster\n    let clusters = points.map((p, idx)=>({\n            points: [\n                idx\n            ],\n            center: {\n                x: p.x,\n                y: p.y\n            }\n        }));\n    let stepNumber = 0;\n    // Record initial state\n    steps.push({\n        stepNumber: stepNumber++,\n        description: `All ${points.length} points start as individual clusters`,\n        cluster1: [],\n        cluster2: [],\n        mergedCluster: [],\n        distance: 0,\n        action: \"connect\"\n    });\n    // Build distance matrix for efficiency\n    const distanceMatrix = [];\n    for(let i = 0; i < points.length; i++){\n        distanceMatrix[i] = [];\n        for(let j = 0; j < points.length; j++){\n            if (i === j) {\n                distanceMatrix[i][j] = 0;\n            } else {\n                distanceMatrix[i][j] = euclideanDistance(points[i], points[j]);\n            }\n        }\n    }\n    // Track which clusters are still active\n    const activeClusters = new Set();\n    for(let i = 0; i < clusters.length; i++){\n        activeClusters.add(i);\n    }\n    // Merge until we have one cluster\n    while(activeClusters.size > 1){\n        // Find the two closest clusters\n        let minDistance = Infinity;\n        let mergeI = -1;\n        let mergeJ = -1;\n        const activeArray = Array.from(activeClusters);\n        for(let i = 0; i < activeArray.length; i++){\n            for(let j = i + 1; j < activeArray.length; j++){\n                const clusterI = activeArray[i];\n                const clusterJ = activeArray[j];\n                const dist = clusterDistance(clusters[clusterI], clusters[clusterJ], points);\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    mergeI = clusterI;\n                    mergeJ = clusterJ;\n                }\n            }\n        }\n        if (mergeI === -1 || mergeJ === -1) break;\n        const cluster1 = clusters[mergeI];\n        const cluster2 = clusters[mergeJ];\n        // Merge the clusters\n        const mergedPoints = [\n            ...cluster1.points,\n            ...cluster2.points\n        ];\n        const mergedCluster = {\n            points: mergedPoints,\n            center: {\n                x: 0,\n                y: 0\n            }\n        };\n        mergedCluster.center = getClusterCenter(mergedCluster, points);\n        // Record this step\n        const action = cluster1.points.length === 1 && cluster2.points.length === 1 ? \"connect\" : \"merge\";\n        steps.push({\n            stepNumber: stepNumber++,\n            description: action === \"connect\" ? `Connecting ${points[cluster1.points[0]]?.id} and ${points[cluster2.points[0]]?.id} (distance: ${minDistance.toFixed(2)})` : `Merging cluster of ${cluster1.points.length} with cluster of ${cluster2.points.length} (distance: ${minDistance.toFixed(2)})`,\n            cluster1: cluster1.points,\n            cluster2: cluster2.points,\n            mergedCluster: mergedPoints,\n            distance: minDistance,\n            action\n        });\n        // Update clusters array\n        clusters.push(mergedCluster);\n        const newClusterIndex = clusters.length - 1;\n        // Remove old clusters from active set and add new one\n        activeClusters.delete(mergeI);\n        activeClusters.delete(mergeJ);\n        activeClusters.add(newClusterIndex);\n    }\n    steps.push({\n        stepNumber: stepNumber++,\n        description: \"Clustering complete - all points merged into one cluster\",\n        cluster1: [],\n        cluster2: [],\n        mergedCluster: clusters[clusters.length - 1]?.points || [],\n        distance: 0,\n        action: \"complete\"\n    });\n    // Build dendrogram tree\n    const dendrogram = buildDendrogram(steps, points);\n    return {\n        steps,\n        dendrogram,\n        finalClusters: getFinalClusters(steps, points.length, 3)\n    };\n}\n// Divisive (Top-Down) Hierarchical Clustering\nfunction divisiveClustering(points) {\n    const steps = [];\n    // Start with all points in one cluster\n    let clusters = [\n        {\n            points: Array.from({\n                length: points.length\n            }, (_, i)=>i),\n            center: {\n                x: 0,\n                y: 0\n            }\n        }\n    ];\n    clusters[0].center = getClusterCenter(clusters[0], points);\n    let stepNumber = 0;\n    // Record initial state\n    steps.push({\n        stepNumber: stepNumber++,\n        description: `All ${points.length} points start in one large cluster`,\n        cluster1: [],\n        cluster2: [],\n        mergedCluster: Array.from({\n            length: points.length\n        }, (_, i)=>i),\n        distance: 0,\n        action: \"connect\"\n    });\n    // Divide until each cluster has reasonable size\n    while(clusters.length < Math.min(points.length, 4)){\n        // Find the largest cluster to split\n        let maxSize = 0;\n        let splitIdx = 0;\n        clusters.forEach((cluster, idx)=>{\n            if (cluster.points.length > maxSize) {\n                maxSize = cluster.points.length;\n                splitIdx = idx;\n            }\n        });\n        if (clusters[splitIdx].points.length <= 1) break;\n        // Split using k-means (k=2) on this cluster\n        const clusterToSplit = clusters[splitIdx];\n        const { cluster1, cluster2 } = splitCluster(clusterToSplit, points);\n        if (cluster1.points.length === 0 || cluster2.points.length === 0) break;\n        steps.push({\n            stepNumber: stepNumber++,\n            description: `Dividing cluster of ${clusterToSplit.points.length} into ${cluster1.points.length} and ${cluster2.points.length}`,\n            cluster1: cluster1.points,\n            cluster2: cluster2.points,\n            mergedCluster: clusterToSplit.points,\n            distance: euclideanDistance(cluster1.center, cluster2.center),\n            action: \"merge\"\n        });\n        // Replace the split cluster with two new clusters\n        clusters.splice(splitIdx, 1, cluster1, cluster2);\n    }\n    steps.push({\n        stepNumber: stepNumber++,\n        description: \"Clustering complete - all clusters divided\",\n        cluster1: [],\n        cluster2: [],\n        mergedCluster: [],\n        distance: 0,\n        action: \"complete\"\n    });\n    // Build dendrogram for divisive clustering\n    const dendrogram = buildDivisiveDendrogram(steps, points);\n    return {\n        steps,\n        dendrogram,\n        finalClusters: clusters.map((c)=>c.points)\n    };\n}\n// Split a cluster into two using k-means (k=2)\nfunction splitCluster(cluster, points) {\n    if (cluster.points.length <= 1) {\n        return {\n            cluster1: cluster,\n            cluster2: {\n                points: [],\n                center: {\n                    x: 0,\n                    y: 0\n                }\n            }\n        };\n    }\n    // Initialize two centroids randomly from cluster points\n    const indices = cluster.points;\n    const c1Idx = indices[0];\n    const c2Idx = indices[Math.floor(indices.length / 2)];\n    let centroid1 = {\n        ...points[c1Idx]\n    };\n    let centroid2 = {\n        ...points[c2Idx]\n    };\n    let assignment = new Array(points.length).fill(0);\n    let changed = true;\n    let iterations = 0;\n    // Run k-means for a few iterations\n    while(changed && iterations < 10){\n        changed = false;\n        iterations++;\n        // Assign points to nearest centroid\n        for (const idx of indices){\n            if (!points[idx]) continue;\n            const dist1 = euclideanDistance(points[idx], centroid1);\n            const dist2 = euclideanDistance(points[idx], centroid2);\n            const newAssignment = dist1 < dist2 ? 0 : 1;\n            if (assignment[idx] !== newAssignment) {\n                assignment[idx] = newAssignment;\n                changed = true;\n            }\n        }\n        // Update centroids\n        const group1 = indices.filter((idx)=>assignment[idx] === 0);\n        const group2 = indices.filter((idx)=>assignment[idx] === 1);\n        if (group1.length > 0) {\n            centroid1 = {\n                x: group1.reduce((sum, idx)=>sum + points[idx].x, 0) / group1.length,\n                y: group1.reduce((sum, idx)=>sum + points[idx].y, 0) / group1.length,\n                id: \"\",\n                data: null\n            };\n        }\n        if (group2.length > 0) {\n            centroid2 = {\n                x: group2.reduce((sum, idx)=>sum + points[idx].x, 0) / group2.length,\n                y: group2.reduce((sum, idx)=>sum + points[idx].y, 0) / group2.length,\n                id: \"\",\n                data: null\n            };\n        }\n    }\n    const group1 = indices.filter((idx)=>assignment[idx] === 0);\n    const group2 = indices.filter((idx)=>assignment[idx] === 1);\n    return {\n        cluster1: {\n            points: group1,\n            center: centroid1\n        },\n        cluster2: {\n            points: group2,\n            center: centroid2\n        }\n    };\n}\n// Get final clusters from steps\nfunction getFinalClusters(steps, numPoints, targetClusters) {\n    if (steps.length === 0) {\n        return [\n            Array.from({\n                length: numPoints\n            }, (_, i)=>i)\n        ];\n    }\n    // Get clusters at a specific step that gives us close to targetClusters\n    const targetStep = Math.max(0, steps.length - targetClusters - 1);\n    // Track which points belong to which cluster\n    const pointToCluster = new Map();\n    const clusters = new Map();\n    // Initialize each point as its own cluster\n    for(let i = 0; i < numPoints; i++){\n        pointToCluster.set(i, i);\n        clusters.set(i, new Set([\n            i\n        ]));\n    }\n    // Apply merges up to targetStep\n    for(let i = 0; i < Math.min(targetStep, steps.length); i++){\n        const step = steps[i];\n        if (step.action === \"complete\") continue;\n        const cluster1Id = pointToCluster.get(step.cluster1[0]);\n        const cluster2Id = pointToCluster.get(step.cluster2[0]);\n        if (cluster1Id === undefined || cluster2Id === undefined) continue;\n        const cluster1Points = clusters.get(cluster1Id);\n        const cluster2Points = clusters.get(cluster2Id);\n        if (!cluster1Points || !cluster2Points) continue;\n        // Merge cluster2 into cluster1\n        cluster2Points.forEach((point)=>{\n            cluster1Points.add(point);\n            pointToCluster.set(point, cluster1Id);\n        });\n        clusters.delete(cluster2Id);\n    }\n    // Convert to array format\n    return Array.from(clusters.values()).map((cluster)=>Array.from(cluster));\n}\n// Build dendrogram tree for agglomerative clustering\nfunction buildDendrogram(steps, points) {\n    if (steps.length === 0) return null;\n    // Create leaf nodes for each point\n    const leafNodes = points.map((p, idx)=>({\n            height: 0,\n            label: p.id,\n            indices: [\n                idx\n            ]\n        }));\n    // Track which nodes are still active\n    const activeNodes = new Map();\n    leafNodes.forEach((node, idx)=>{\n        activeNodes.set(`leaf_${idx}`, node);\n    });\n    // Process merge steps to build the tree\n    for(let i = 1; i < steps.length - 1; i++){\n        const step = steps[i];\n        if (step.action === \"complete\") continue;\n        // Find the nodes corresponding to the clusters being merged\n        let node1 = null;\n        let node2 = null;\n        let node1Key = \"\";\n        let node2Key = \"\";\n        // Search for nodes that contain the points from the clusters\n        for (const [key, node] of Array.from(activeNodes.entries())){\n            if (node.indices && step.cluster1.length > 0) {\n                // Check if this node contains any point from cluster1\n                const hasCluster1Point = step.cluster1.some((pointIdx)=>node.indices?.includes(pointIdx));\n                if (hasCluster1Point && !node1) {\n                    node1 = node;\n                    node1Key = key;\n                }\n            }\n            if (node.indices && step.cluster2.length > 0) {\n                // Check if this node contains any point from cluster2\n                const hasCluster2Point = step.cluster2.some((pointIdx)=>node.indices?.includes(pointIdx));\n                if (hasCluster2Point && !node2) {\n                    node2 = node;\n                    node2Key = key;\n                }\n            }\n        }\n        if (node1 && node2 && node1Key !== node2Key) {\n            // Create new merged node\n            const mergedNode = {\n                left: node1,\n                right: node2,\n                height: step.distance,\n                indices: step.mergedCluster\n            };\n            // Remove old nodes and add new one\n            activeNodes.delete(node1Key);\n            activeNodes.delete(node2Key);\n            activeNodes.set(`merge_${i}`, mergedNode);\n        }\n    }\n    // Return the root node (should be the only remaining node)\n    const rootNodes = Array.from(activeNodes.values());\n    const rootNode = rootNodes.length > 0 ? rootNodes[0] : null;\n    // Ensure all points are represented in the tree\n    if (rootNode) {\n        const allPointIds = new Set();\n        const collectAllLabels = (node)=>{\n            if (node.label) {\n                allPointIds.add(node.label);\n            }\n            if (node.left) collectAllLabels(node.left);\n            if (node.right) collectAllLabels(node.right);\n        };\n        collectAllLabels(rootNode);\n        // If any points are missing, create a simple tree that includes them all\n        const missingPoints = points.filter((p)=>!allPointIds.has(p.id));\n        if (missingPoints.length > 0) {\n            // Create a simple balanced tree with all points\n            const allLeafNodes = points.map((p, idx)=>({\n                    height: 0,\n                    label: p.id,\n                    indices: [\n                        idx\n                    ]\n                }));\n            return buildBalancedTree(allLeafNodes, 0);\n        }\n    }\n    return rootNode;\n}\n// Helper function to build a balanced tree from leaf nodes\nfunction buildBalancedTree(leafNodes, startHeight) {\n    if (leafNodes.length === 1) {\n        return leafNodes[0];\n    }\n    if (leafNodes.length === 2) {\n        return {\n            left: leafNodes[0],\n            right: leafNodes[1],\n            height: startHeight + 1,\n            indices: [\n                ...leafNodes[0].indices || [],\n                ...leafNodes[1].indices || []\n            ]\n        };\n    }\n    const mid = Math.floor(leafNodes.length / 2);\n    const left = buildBalancedTree(leafNodes.slice(0, mid), startHeight + 1);\n    const right = buildBalancedTree(leafNodes.slice(mid), startHeight + 1);\n    return {\n        left,\n        right,\n        height: startHeight + 1,\n        indices: [\n            ...left.indices || [],\n            ...right.indices || []\n        ]\n    };\n}\n// Build dendrogram tree for divisive clustering\nfunction buildDivisiveDendrogram(steps, points) {\n    if (steps.length === 0) return null;\n    // Start with root node containing all points\n    const rootNode = {\n        height: 0,\n        indices: Array.from({\n            length: points.length\n        }, (_, i)=>i)\n    };\n    // Process division steps to build the tree\n    const nodeMap = new Map();\n    nodeMap.set(\"root\", rootNode);\n    for(let i = 1; i < steps.length - 1; i++){\n        const step = steps[i];\n        if (step.action === \"complete\") continue;\n        // Find the node to split\n        const nodeToSplit = Array.from(nodeMap.values()).find((node)=>node.indices && step.mergedCluster.length > 0 && node.indices.includes(step.mergedCluster[0]));\n        if (nodeToSplit) {\n            // Create child nodes\n            const leftNode = {\n                height: step.distance,\n                indices: step.cluster1\n            };\n            const rightNode = {\n                height: step.distance,\n                indices: step.cluster2\n            };\n            // Update the parent node\n            nodeToSplit.left = leftNode;\n            nodeToSplit.right = rightNode;\n            nodeToSplit.height = step.distance;\n            // Add child nodes to map\n            nodeMap.set(`left_${i}`, leftNode);\n            nodeMap.set(`right_${i}`, rightNode);\n        }\n    }\n    // Add leaf nodes for individual points\n    const addLeafNodes = (node)=>{\n        if (node.indices && node.indices.length === 1) {\n            const pointIdx = node.indices[0];\n            node.label = points[pointIdx]?.id;\n            node.height = 0;\n        } else {\n            if (node.left) addLeafNodes(node.left);\n            if (node.right) addLeafNodes(node.right);\n        }\n    };\n    addLeafNodes(rootNode);\n    // Ensure all points are represented as leaf nodes\n    const allPointIds = new Set();\n    const collectLeafLabels = (node)=>{\n        if (node.label) {\n            allPointIds.add(node.label);\n        } else {\n            if (node.left) collectLeafLabels(node.left);\n            if (node.right) collectLeafLabels(node.right);\n        }\n    };\n    collectLeafLabels(rootNode);\n    // If any points are missing, create a complete tree with all points\n    const missingPoints = points.filter((p)=>!allPointIds.has(p.id));\n    if (missingPoints.length > 0) {\n        // Create a simple balanced tree with all points\n        const allLeafNodes = points.map((p, idx)=>({\n                height: 0,\n                label: p.id,\n                indices: [\n                    idx\n                ]\n            }));\n        return buildBalancedTree(allLeafNodes, 0);\n    }\n    return rootNode;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEVBQUU7WUFDaEN1QyxLQUFLRixLQUFLLEdBQUdqRyxNQUFNLENBQUM0RyxTQUFTLEVBQUVuRTtZQUMvQjBELEtBQUtILE1BQU0sR0FBRztRQUNoQixPQUFPO1lBQ0wsSUFBSUcsS0FBS2EsSUFBSSxFQUFFa0IsYUFBYS9CLEtBQUthLElBQUk7WUFDckMsSUFBSWIsS0FBS2MsS0FBSyxFQUFFaUIsYUFBYS9CLEtBQUtjLEtBQUs7UUFDekM7SUFDRjtJQUVBaUIsYUFBYWY7SUFFYixrREFBa0Q7SUFDbEQsTUFBTUMsY0FBYyxJQUFJeEY7SUFDeEIsTUFBTXVHLG9CQUFvQixDQUFDaEM7UUFDekIsSUFBSUEsS0FBS0YsS0FBSyxFQUFFO1lBQ2RtQixZQUFZdkYsR0FBRyxDQUFDc0UsS0FBS0YsS0FBSztRQUM1QixPQUFPO1lBQ0wsSUFBSUUsS0FBS2EsSUFBSSxFQUFFbUIsa0JBQWtCaEMsS0FBS2EsSUFBSTtZQUMxQyxJQUFJYixLQUFLYyxLQUFLLEVBQUVrQixrQkFBa0JoQyxLQUFLYyxLQUFLO1FBQzlDO0lBQ0Y7SUFFQWtCLGtCQUFrQmhCO0lBRWxCLG9FQUFvRTtJQUNwRSxNQUFNRyxnQkFBZ0J0SCxPQUFPMEUsTUFBTSxDQUFDM0QsQ0FBQUEsSUFBSyxDQUFDcUcsWUFBWUcsR0FBRyxDQUFDeEcsRUFBRTBCLEVBQUU7SUFDOUQsSUFBSTZFLGNBQWNsRyxNQUFNLEdBQUcsR0FBRztRQUM1QixnREFBZ0Q7UUFDaEQsTUFBTW9HLGVBQWV4SCxPQUFPYyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0wsTUFBUztnQkFDM0NzRixRQUFRO2dCQUNSQyxPQUFPbEYsRUFBRTBCLEVBQUU7Z0JBQ1htQixTQUFTO29CQUFDbEQ7aUJBQUk7WUFDaEI7UUFFQSxPQUFPK0csa0JBQWtCRCxjQUFjO0lBQ3pDO0lBRUEsT0FBT0w7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2hpZXJhcmNoaWNhbC1jbHVzdGVyaW5nLXZpc3VhbGl6YXRpb24vLi9hcHAvbGliL2NsdXN0ZXJpbmcudHM/ZjViNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgUG9pbnQge1xuICBpZDogc3RyaW5nO1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgZGF0YTogYW55O1xufVxuXG5pbnRlcmZhY2UgQ2x1c3RlciB7XG4gIHBvaW50czogbnVtYmVyW107XG4gIGNlbnRlcjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xufVxuXG5pbnRlcmZhY2UgTWVyZ2VTdGVwIHtcbiAgc3RlcE51bWJlcjogbnVtYmVyO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBjbHVzdGVyMTogbnVtYmVyW107XG4gIGNsdXN0ZXIyOiBudW1iZXJbXTtcbiAgbWVyZ2VkQ2x1c3RlcjogbnVtYmVyW107XG4gIGRpc3RhbmNlOiBudW1iZXI7XG4gIGFjdGlvbjogJ2Nvbm5lY3QnIHwgJ21lcmdlJyB8ICdjb21wbGV0ZSc7XG59XG5cbmludGVyZmFjZSBEZW5kcm9ncmFtTm9kZSB7XG4gIGxlZnQ/OiBEZW5kcm9ncmFtTm9kZTtcbiAgcmlnaHQ/OiBEZW5kcm9ncmFtTm9kZTtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBpbmRpY2VzPzogbnVtYmVyW107XG59XG5cbi8vIENhbGN1bGF0ZSBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG5leHBvcnQgZnVuY3Rpb24gZXVjbGlkZWFuRGlzdGFuY2UocDE6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSwgcDI6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHAxLnggLSBwMi54KSAqKiAyICsgKHAxLnkgLSBwMi55KSAqKiAyKTtcbn1cblxuLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNsdXN0ZXJzIChhdmVyYWdlIGxpbmthZ2UpXG5mdW5jdGlvbiBjbHVzdGVyRGlzdGFuY2UoYzE6IENsdXN0ZXIsIGMyOiBDbHVzdGVyLCBwb2ludHM6IFBvaW50W10pOiBudW1iZXIge1xuICBsZXQgdG90YWxEaXN0YW5jZSA9IDA7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChjb25zdCBpIG9mIGMxLnBvaW50cykge1xuICAgIGZvciAoY29uc3QgaiBvZiBjMi5wb2ludHMpIHtcbiAgICAgIGlmIChwb2ludHNbaV0gJiYgcG9pbnRzW2pdKSB7XG4gICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZXVjbGlkZWFuRGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbal0pO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudCA+IDAgPyB0b3RhbERpc3RhbmNlIC8gY291bnQgOiBJbmZpbml0eTtcbn1cblxuLy8gR2V0IGNsdXN0ZXIgY2VudGVyXG5mdW5jdGlvbiBnZXRDbHVzdGVyQ2VudGVyKGNsdXN0ZXI6IENsdXN0ZXIsIHBvaW50czogUG9pbnRbXSk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGxldCBzdW1YID0gMDtcbiAgbGV0IHN1bVkgPSAwO1xuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAoY29uc3QgaWR4IG9mIGNsdXN0ZXIucG9pbnRzKSB7XG4gICAgaWYgKHBvaW50c1tpZHhdKSB7XG4gICAgICBzdW1YICs9IHBvaW50c1tpZHhdLng7XG4gICAgICBzdW1ZICs9IHBvaW50c1tpZHhdLnk7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudCA+IDAgPyB7IHg6IHN1bVggLyBjb3VudCwgeTogc3VtWSAvIGNvdW50IH0gOiB7IHg6IDAsIHk6IDAgfTtcbn1cblxuLy8gQWdnbG9tZXJhdGl2ZSAoQm90dG9tLVVwKSBIaWVyYXJjaGljYWwgQ2x1c3RlcmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGFnZ2xvbWVyYXRpdmVDbHVzdGVyaW5nKHBvaW50czogUG9pbnRbXSkge1xuICBjb25zdCBzdGVwczogTWVyZ2VTdGVwW10gPSBbXTtcbiAgXG4gIC8vIEluaXRpYWxpemU6IGVhY2ggcG9pbnQgaXMgaXRzIG93biBjbHVzdGVyXG4gIGxldCBjbHVzdGVyczogQ2x1c3RlcltdID0gcG9pbnRzLm1hcCgocCwgaWR4KSA9PiAoe1xuICAgIHBvaW50czogW2lkeF0sXG4gICAgY2VudGVyOiB7IHg6IHAueCwgeTogcC55IH0sXG4gIH0pKTtcblxuICBsZXQgc3RlcE51bWJlciA9IDA7XG5cbiAgLy8gUmVjb3JkIGluaXRpYWwgc3RhdGVcbiAgc3RlcHMucHVzaCh7XG4gICAgc3RlcE51bWJlcjogc3RlcE51bWJlcisrLFxuICAgIGRlc2NyaXB0aW9uOiBgQWxsICR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIHN0YXJ0IGFzIGluZGl2aWR1YWwgY2x1c3RlcnNgLFxuICAgIGNsdXN0ZXIxOiBbXSxcbiAgICBjbHVzdGVyMjogW10sXG4gICAgbWVyZ2VkQ2x1c3RlcjogW10sXG4gICAgZGlzdGFuY2U6IDAsXG4gICAgYWN0aW9uOiAnY29ubmVjdCcsXG4gIH0pO1xuXG4gIC8vIEJ1aWxkIGRpc3RhbmNlIG1hdHJpeCBmb3IgZWZmaWNpZW5jeVxuICBjb25zdCBkaXN0YW5jZU1hdHJpeDogbnVtYmVyW11bXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRpc3RhbmNlTWF0cml4W2ldID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgIGRpc3RhbmNlTWF0cml4W2ldW2pdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3RhbmNlTWF0cml4W2ldW2pdID0gZXVjbGlkZWFuRGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNrIHdoaWNoIGNsdXN0ZXJzIGFyZSBzdGlsbCBhY3RpdmVcbiAgY29uc3QgYWN0aXZlQ2x1c3RlcnMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGFjdGl2ZUNsdXN0ZXJzLmFkZChpKTtcbiAgfVxuXG4gIC8vIE1lcmdlIHVudGlsIHdlIGhhdmUgb25lIGNsdXN0ZXJcbiAgd2hpbGUgKGFjdGl2ZUNsdXN0ZXJzLnNpemUgPiAxKSB7XG4gICAgLy8gRmluZCB0aGUgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgbWVyZ2VJID0gLTE7XG4gICAgbGV0IG1lcmdlSiA9IC0xO1xuXG4gICAgY29uc3QgYWN0aXZlQXJyYXkgPSBBcnJheS5mcm9tKGFjdGl2ZUNsdXN0ZXJzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBhY3RpdmVBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBjbHVzdGVySSA9IGFjdGl2ZUFycmF5W2ldO1xuICAgICAgICBjb25zdCBjbHVzdGVySiA9IGFjdGl2ZUFycmF5W2pdO1xuICAgICAgICBjb25zdCBkaXN0ID0gY2x1c3RlckRpc3RhbmNlKGNsdXN0ZXJzW2NsdXN0ZXJJXSwgY2x1c3RlcnNbY2x1c3RlckpdLCBwb2ludHMpO1xuICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgIG1lcmdlSSA9IGNsdXN0ZXJJO1xuICAgICAgICAgIG1lcmdlSiA9IGNsdXN0ZXJKO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1lcmdlSSA9PT0gLTEgfHwgbWVyZ2VKID09PSAtMSkgYnJlYWs7XG5cbiAgICBjb25zdCBjbHVzdGVyMSA9IGNsdXN0ZXJzW21lcmdlSV07XG4gICAgY29uc3QgY2x1c3RlcjIgPSBjbHVzdGVyc1ttZXJnZUpdO1xuXG4gICAgLy8gTWVyZ2UgdGhlIGNsdXN0ZXJzXG4gICAgY29uc3QgbWVyZ2VkUG9pbnRzID0gWy4uLmNsdXN0ZXIxLnBvaW50cywgLi4uY2x1c3RlcjIucG9pbnRzXTtcbiAgICBjb25zdCBtZXJnZWRDbHVzdGVyOiBDbHVzdGVyID0ge1xuICAgICAgcG9pbnRzOiBtZXJnZWRQb2ludHMsXG4gICAgICBjZW50ZXI6IHsgeDogMCwgeTogMCB9LFxuICAgIH07XG4gICAgbWVyZ2VkQ2x1c3Rlci5jZW50ZXIgPSBnZXRDbHVzdGVyQ2VudGVyKG1lcmdlZENsdXN0ZXIsIHBvaW50cyk7XG5cbiAgICAvLyBSZWNvcmQgdGhpcyBzdGVwXG4gICAgY29uc3QgYWN0aW9uID0gY2x1c3RlcjEucG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBjbHVzdGVyMi5wb2ludHMubGVuZ3RoID09PSAxID8gJ2Nvbm5lY3QnIDogJ21lcmdlJztcbiAgICBcbiAgICBzdGVwcy5wdXNoKHtcbiAgICAgIHN0ZXBOdW1iZXI6IHN0ZXBOdW1iZXIrKyxcbiAgICAgIGRlc2NyaXB0aW9uOiBhY3Rpb24gPT09ICdjb25uZWN0JyBcbiAgICAgICAgPyBgQ29ubmVjdGluZyAke3BvaW50c1tjbHVzdGVyMS5wb2ludHNbMF1dPy5pZH0gYW5kICR7cG9pbnRzW2NsdXN0ZXIyLnBvaW50c1swXV0/LmlkfSAoZGlzdGFuY2U6ICR7bWluRGlzdGFuY2UudG9GaXhlZCgyKX0pYFxuICAgICAgICA6IGBNZXJnaW5nIGNsdXN0ZXIgb2YgJHtjbHVzdGVyMS5wb2ludHMubGVuZ3RofSB3aXRoIGNsdXN0ZXIgb2YgJHtjbHVzdGVyMi5wb2ludHMubGVuZ3RofSAoZGlzdGFuY2U6ICR7bWluRGlzdGFuY2UudG9GaXhlZCgyKX0pYCxcbiAgICAgIGNsdXN0ZXIxOiBjbHVzdGVyMS5wb2ludHMsXG4gICAgICBjbHVzdGVyMjogY2x1c3RlcjIucG9pbnRzLFxuICAgICAgbWVyZ2VkQ2x1c3RlcjogbWVyZ2VkUG9pbnRzLFxuICAgICAgZGlzdGFuY2U6IG1pbkRpc3RhbmNlLFxuICAgICAgYWN0aW9uLFxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGNsdXN0ZXJzIGFycmF5XG4gICAgY2x1c3RlcnMucHVzaChtZXJnZWRDbHVzdGVyKTtcbiAgICBjb25zdCBuZXdDbHVzdGVySW5kZXggPSBjbHVzdGVycy5sZW5ndGggLSAxO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBjbHVzdGVycyBmcm9tIGFjdGl2ZSBzZXQgYW5kIGFkZCBuZXcgb25lXG4gICAgYWN0aXZlQ2x1c3RlcnMuZGVsZXRlKG1lcmdlSSk7XG4gICAgYWN0aXZlQ2x1c3RlcnMuZGVsZXRlKG1lcmdlSik7XG4gICAgYWN0aXZlQ2x1c3RlcnMuYWRkKG5ld0NsdXN0ZXJJbmRleCk7XG4gIH1cblxuICBzdGVwcy5wdXNoKHtcbiAgICBzdGVwTnVtYmVyOiBzdGVwTnVtYmVyKyssXG4gICAgZGVzY3JpcHRpb246ICdDbHVzdGVyaW5nIGNvbXBsZXRlIC0gYWxsIHBvaW50cyBtZXJnZWQgaW50byBvbmUgY2x1c3RlcicsXG4gICAgY2x1c3RlcjE6IFtdLFxuICAgIGNsdXN0ZXIyOiBbXSxcbiAgICBtZXJnZWRDbHVzdGVyOiBjbHVzdGVyc1tjbHVzdGVycy5sZW5ndGggLSAxXT8ucG9pbnRzIHx8IFtdLFxuICAgIGRpc3RhbmNlOiAwLFxuICAgIGFjdGlvbjogJ2NvbXBsZXRlJyxcbiAgfSk7XG5cbiAgLy8gQnVpbGQgZGVuZHJvZ3JhbSB0cmVlXG4gIGNvbnN0IGRlbmRyb2dyYW0gPSBidWlsZERlbmRyb2dyYW0oc3RlcHMsIHBvaW50cyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGVwcyxcbiAgICBkZW5kcm9ncmFtLFxuICAgIGZpbmFsQ2x1c3RlcnM6IGdldEZpbmFsQ2x1c3RlcnMoc3RlcHMsIHBvaW50cy5sZW5ndGgsIDMpLCAvLyBHZXQgMy00IGZpbmFsIGNsdXN0ZXJzXG4gIH07XG59XG5cbi8vIERpdmlzaXZlIChUb3AtRG93bikgSGllcmFyY2hpY2FsIENsdXN0ZXJpbmdcbmV4cG9ydCBmdW5jdGlvbiBkaXZpc2l2ZUNsdXN0ZXJpbmcocG9pbnRzOiBQb2ludFtdKSB7XG4gIGNvbnN0IHN0ZXBzOiBNZXJnZVN0ZXBbXSA9IFtdO1xuICBcbiAgLy8gU3RhcnQgd2l0aCBhbGwgcG9pbnRzIGluIG9uZSBjbHVzdGVyXG4gIGxldCBjbHVzdGVyczogQ2x1c3RlcltdID0gW3tcbiAgICBwb2ludHM6IEFycmF5LmZyb20oeyBsZW5ndGg6IHBvaW50cy5sZW5ndGggfSwgKF8sIGkpID0+IGkpLFxuICAgIGNlbnRlcjogeyB4OiAwLCB5OiAwIH0sXG4gIH1dO1xuICBjbHVzdGVyc1swXS5jZW50ZXIgPSBnZXRDbHVzdGVyQ2VudGVyKGNsdXN0ZXJzWzBdLCBwb2ludHMpO1xuXG4gIGxldCBzdGVwTnVtYmVyID0gMDtcblxuICAvLyBSZWNvcmQgaW5pdGlhbCBzdGF0ZVxuICBzdGVwcy5wdXNoKHtcbiAgICBzdGVwTnVtYmVyOiBzdGVwTnVtYmVyKyssXG4gICAgZGVzY3JpcHRpb246IGBBbGwgJHtwb2ludHMubGVuZ3RofSBwb2ludHMgc3RhcnQgaW4gb25lIGxhcmdlIGNsdXN0ZXJgLFxuICAgIGNsdXN0ZXIxOiBbXSxcbiAgICBjbHVzdGVyMjogW10sXG4gICAgbWVyZ2VkQ2x1c3RlcjogQXJyYXkuZnJvbSh7IGxlbmd0aDogcG9pbnRzLmxlbmd0aCB9LCAoXywgaSkgPT4gaSksXG4gICAgZGlzdGFuY2U6IDAsXG4gICAgYWN0aW9uOiAnY29ubmVjdCcsXG4gIH0pO1xuXG4gIC8vIERpdmlkZSB1bnRpbCBlYWNoIGNsdXN0ZXIgaGFzIHJlYXNvbmFibGUgc2l6ZVxuICB3aGlsZSAoY2x1c3RlcnMubGVuZ3RoIDwgTWF0aC5taW4ocG9pbnRzLmxlbmd0aCwgNCkpIHtcbiAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IGNsdXN0ZXIgdG8gc3BsaXRcbiAgICBsZXQgbWF4U2l6ZSA9IDA7XG4gICAgbGV0IHNwbGl0SWR4ID0gMDtcblxuICAgIGNsdXN0ZXJzLmZvckVhY2goKGNsdXN0ZXIsIGlkeCkgPT4ge1xuICAgICAgaWYgKGNsdXN0ZXIucG9pbnRzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgbWF4U2l6ZSA9IGNsdXN0ZXIucG9pbnRzLmxlbmd0aDtcbiAgICAgICAgc3BsaXRJZHggPSBpZHg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY2x1c3RlcnNbc3BsaXRJZHhdLnBvaW50cy5sZW5ndGggPD0gMSkgYnJlYWs7XG5cbiAgICAvLyBTcGxpdCB1c2luZyBrLW1lYW5zIChrPTIpIG9uIHRoaXMgY2x1c3RlclxuICAgIGNvbnN0IGNsdXN0ZXJUb1NwbGl0ID0gY2x1c3RlcnNbc3BsaXRJZHhdO1xuICAgIGNvbnN0IHsgY2x1c3RlcjEsIGNsdXN0ZXIyIH0gPSBzcGxpdENsdXN0ZXIoY2x1c3RlclRvU3BsaXQsIHBvaW50cyk7XG5cbiAgICBpZiAoY2x1c3RlcjEucG9pbnRzLmxlbmd0aCA9PT0gMCB8fCBjbHVzdGVyMi5wb2ludHMubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgIHN0ZXBzLnB1c2goe1xuICAgICAgc3RlcE51bWJlcjogc3RlcE51bWJlcisrLFxuICAgICAgZGVzY3JpcHRpb246IGBEaXZpZGluZyBjbHVzdGVyIG9mICR7Y2x1c3RlclRvU3BsaXQucG9pbnRzLmxlbmd0aH0gaW50byAke2NsdXN0ZXIxLnBvaW50cy5sZW5ndGh9IGFuZCAke2NsdXN0ZXIyLnBvaW50cy5sZW5ndGh9YCxcbiAgICAgIGNsdXN0ZXIxOiBjbHVzdGVyMS5wb2ludHMsXG4gICAgICBjbHVzdGVyMjogY2x1c3RlcjIucG9pbnRzLFxuICAgICAgbWVyZ2VkQ2x1c3RlcjogY2x1c3RlclRvU3BsaXQucG9pbnRzLFxuICAgICAgZGlzdGFuY2U6IGV1Y2xpZGVhbkRpc3RhbmNlKGNsdXN0ZXIxLmNlbnRlciwgY2x1c3RlcjIuY2VudGVyKSxcbiAgICAgIGFjdGlvbjogJ21lcmdlJyxcbiAgICB9KTtcblxuICAgIC8vIFJlcGxhY2UgdGhlIHNwbGl0IGNsdXN0ZXIgd2l0aCB0d28gbmV3IGNsdXN0ZXJzXG4gICAgY2x1c3RlcnMuc3BsaWNlKHNwbGl0SWR4LCAxLCBjbHVzdGVyMSwgY2x1c3RlcjIpO1xuICB9XG5cbiAgc3RlcHMucHVzaCh7XG4gICAgc3RlcE51bWJlcjogc3RlcE51bWJlcisrLFxuICAgIGRlc2NyaXB0aW9uOiAnQ2x1c3RlcmluZyBjb21wbGV0ZSAtIGFsbCBjbHVzdGVycyBkaXZpZGVkJyxcbiAgICBjbHVzdGVyMTogW10sXG4gICAgY2x1c3RlcjI6IFtdLFxuICAgIG1lcmdlZENsdXN0ZXI6IFtdLFxuICAgIGRpc3RhbmNlOiAwLFxuICAgIGFjdGlvbjogJ2NvbXBsZXRlJyxcbiAgfSk7XG5cbiAgLy8gQnVpbGQgZGVuZHJvZ3JhbSBmb3IgZGl2aXNpdmUgY2x1c3RlcmluZ1xuICBjb25zdCBkZW5kcm9ncmFtID0gYnVpbGREaXZpc2l2ZURlbmRyb2dyYW0oc3RlcHMsIHBvaW50cyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGVwcyxcbiAgICBkZW5kcm9ncmFtLFxuICAgIGZpbmFsQ2x1c3RlcnM6IGNsdXN0ZXJzLm1hcChjID0+IGMucG9pbnRzKSxcbiAgfTtcbn1cblxuLy8gU3BsaXQgYSBjbHVzdGVyIGludG8gdHdvIHVzaW5nIGstbWVhbnMgKGs9MilcbmZ1bmN0aW9uIHNwbGl0Q2x1c3RlcihjbHVzdGVyOiBDbHVzdGVyLCBwb2ludHM6IFBvaW50W10pOiB7IGNsdXN0ZXIxOiBDbHVzdGVyOyBjbHVzdGVyMjogQ2x1c3RlciB9IHtcbiAgaWYgKGNsdXN0ZXIucG9pbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsdXN0ZXIxOiBjbHVzdGVyLFxuICAgICAgY2x1c3RlcjI6IHsgcG9pbnRzOiBbXSwgY2VudGVyOiB7IHg6IDAsIHk6IDAgfSB9LFxuICAgIH07XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHR3byBjZW50cm9pZHMgcmFuZG9tbHkgZnJvbSBjbHVzdGVyIHBvaW50c1xuICBjb25zdCBpbmRpY2VzID0gY2x1c3Rlci5wb2ludHM7XG4gIGNvbnN0IGMxSWR4ID0gaW5kaWNlc1swXTtcbiAgY29uc3QgYzJJZHggPSBpbmRpY2VzW01hdGguZmxvb3IoaW5kaWNlcy5sZW5ndGggLyAyKV07XG5cbiAgbGV0IGNlbnRyb2lkMSA9IHsgLi4ucG9pbnRzW2MxSWR4XSB9O1xuICBsZXQgY2VudHJvaWQyID0geyAuLi5wb2ludHNbYzJJZHhdIH07XG5cbiAgbGV0IGFzc2lnbm1lbnQ6IG51bWJlcltdID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGgpLmZpbGwoMCk7XG4gIGxldCBjaGFuZ2VkID0gdHJ1ZTtcbiAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuXG4gIC8vIFJ1biBrLW1lYW5zIGZvciBhIGZldyBpdGVyYXRpb25zXG4gIHdoaWxlIChjaGFuZ2VkICYmIGl0ZXJhdGlvbnMgPCAxMCkge1xuICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpdGVyYXRpb25zKys7XG5cbiAgICAvLyBBc3NpZ24gcG9pbnRzIHRvIG5lYXJlc3QgY2VudHJvaWRcbiAgICBmb3IgKGNvbnN0IGlkeCBvZiBpbmRpY2VzKSB7XG4gICAgICBpZiAoIXBvaW50c1tpZHhdKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzdDEgPSBldWNsaWRlYW5EaXN0YW5jZShwb2ludHNbaWR4XSwgY2VudHJvaWQxKTtcbiAgICAgIGNvbnN0IGRpc3QyID0gZXVjbGlkZWFuRGlzdGFuY2UocG9pbnRzW2lkeF0sIGNlbnRyb2lkMik7XG4gICAgICBjb25zdCBuZXdBc3NpZ25tZW50ID0gZGlzdDEgPCBkaXN0MiA/IDAgOiAxO1xuXG4gICAgICBpZiAoYXNzaWdubWVudFtpZHhdICE9PSBuZXdBc3NpZ25tZW50KSB7XG4gICAgICAgIGFzc2lnbm1lbnRbaWR4XSA9IG5ld0Fzc2lnbm1lbnQ7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjZW50cm9pZHNcbiAgICBjb25zdCBncm91cDEgPSBpbmRpY2VzLmZpbHRlcihpZHggPT4gYXNzaWdubWVudFtpZHhdID09PSAwKTtcbiAgICBjb25zdCBncm91cDIgPSBpbmRpY2VzLmZpbHRlcihpZHggPT4gYXNzaWdubWVudFtpZHhdID09PSAxKTtcblxuICAgIGlmIChncm91cDEubGVuZ3RoID4gMCkge1xuICAgICAgY2VudHJvaWQxID0ge1xuICAgICAgICB4OiBncm91cDEucmVkdWNlKChzdW0sIGlkeCkgPT4gc3VtICsgcG9pbnRzW2lkeF0ueCwgMCkgLyBncm91cDEubGVuZ3RoLFxuICAgICAgICB5OiBncm91cDEucmVkdWNlKChzdW0sIGlkeCkgPT4gc3VtICsgcG9pbnRzW2lkeF0ueSwgMCkgLyBncm91cDEubGVuZ3RoLFxuICAgICAgICBpZDogJycsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChncm91cDIubGVuZ3RoID4gMCkge1xuICAgICAgY2VudHJvaWQyID0ge1xuICAgICAgICB4OiBncm91cDIucmVkdWNlKChzdW0sIGlkeCkgPT4gc3VtICsgcG9pbnRzW2lkeF0ueCwgMCkgLyBncm91cDIubGVuZ3RoLFxuICAgICAgICB5OiBncm91cDIucmVkdWNlKChzdW0sIGlkeCkgPT4gc3VtICsgcG9pbnRzW2lkeF0ueSwgMCkgLyBncm91cDIubGVuZ3RoLFxuICAgICAgICBpZDogJycsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGdyb3VwMSA9IGluZGljZXMuZmlsdGVyKGlkeCA9PiBhc3NpZ25tZW50W2lkeF0gPT09IDApO1xuICBjb25zdCBncm91cDIgPSBpbmRpY2VzLmZpbHRlcihpZHggPT4gYXNzaWdubWVudFtpZHhdID09PSAxKTtcblxuICByZXR1cm4ge1xuICAgIGNsdXN0ZXIxOiB7XG4gICAgICBwb2ludHM6IGdyb3VwMSxcbiAgICAgIGNlbnRlcjogY2VudHJvaWQxLFxuICAgIH0sXG4gICAgY2x1c3RlcjI6IHtcbiAgICAgIHBvaW50czogZ3JvdXAyLFxuICAgICAgY2VudGVyOiBjZW50cm9pZDIsXG4gICAgfSxcbiAgfTtcbn1cblxuLy8gR2V0IGZpbmFsIGNsdXN0ZXJzIGZyb20gc3RlcHNcbmZ1bmN0aW9uIGdldEZpbmFsQ2x1c3RlcnMoc3RlcHM6IE1lcmdlU3RlcFtdLCBudW1Qb2ludHM6IG51bWJlciwgdGFyZ2V0Q2x1c3RlcnM6IG51bWJlcik6IG51bWJlcltdW10ge1xuICBpZiAoc3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtBcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1Qb2ludHMgfSwgKF8sIGkpID0+IGkpXTtcbiAgfVxuXG4gIC8vIEdldCBjbHVzdGVycyBhdCBhIHNwZWNpZmljIHN0ZXAgdGhhdCBnaXZlcyB1cyBjbG9zZSB0byB0YXJnZXRDbHVzdGVyc1xuICBjb25zdCB0YXJnZXRTdGVwID0gTWF0aC5tYXgoMCwgc3RlcHMubGVuZ3RoIC0gdGFyZ2V0Q2x1c3RlcnMgLSAxKTtcbiAgXG4gIC8vIFRyYWNrIHdoaWNoIHBvaW50cyBiZWxvbmcgdG8gd2hpY2ggY2x1c3RlclxuICBjb25zdCBwb2ludFRvQ2x1c3RlciA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG4gIGNvbnN0IGNsdXN0ZXJzID0gbmV3IE1hcDxudW1iZXIsIFNldDxudW1iZXI+PigpO1xuXG4gIC8vIEluaXRpYWxpemUgZWFjaCBwb2ludCBhcyBpdHMgb3duIGNsdXN0ZXJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgIHBvaW50VG9DbHVzdGVyLnNldChpLCBpKTtcbiAgICBjbHVzdGVycy5zZXQoaSwgbmV3IFNldChbaV0pKTtcbiAgfVxuXG4gIC8vIEFwcGx5IG1lcmdlcyB1cCB0byB0YXJnZXRTdGVwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4odGFyZ2V0U3RlcCwgc3RlcHMubGVuZ3RoKTsgaSsrKSB7XG4gICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2ldO1xuICAgIGlmIChzdGVwLmFjdGlvbiA9PT0gJ2NvbXBsZXRlJykgY29udGludWU7XG5cbiAgICBjb25zdCBjbHVzdGVyMUlkID0gcG9pbnRUb0NsdXN0ZXIuZ2V0KHN0ZXAuY2x1c3RlcjFbMF0pO1xuICAgIGNvbnN0IGNsdXN0ZXIySWQgPSBwb2ludFRvQ2x1c3Rlci5nZXQoc3RlcC5jbHVzdGVyMlswXSk7XG5cbiAgICBpZiAoY2x1c3RlcjFJZCA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXIySWQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICBjb25zdCBjbHVzdGVyMVBvaW50cyA9IGNsdXN0ZXJzLmdldChjbHVzdGVyMUlkKTtcbiAgICBjb25zdCBjbHVzdGVyMlBvaW50cyA9IGNsdXN0ZXJzLmdldChjbHVzdGVyMklkKTtcblxuICAgIGlmICghY2x1c3RlcjFQb2ludHMgfHwgIWNsdXN0ZXIyUG9pbnRzKSBjb250aW51ZTtcblxuICAgIC8vIE1lcmdlIGNsdXN0ZXIyIGludG8gY2x1c3RlcjFcbiAgICBjbHVzdGVyMlBvaW50cy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgIGNsdXN0ZXIxUG9pbnRzLmFkZChwb2ludCk7XG4gICAgICBwb2ludFRvQ2x1c3Rlci5zZXQocG9pbnQsIGNsdXN0ZXIxSWQpO1xuICAgIH0pO1xuXG4gICAgY2x1c3RlcnMuZGVsZXRlKGNsdXN0ZXIySWQpO1xuICB9XG5cbiAgLy8gQ29udmVydCB0byBhcnJheSBmb3JtYXRcbiAgcmV0dXJuIEFycmF5LmZyb20oY2x1c3RlcnMudmFsdWVzKCkpLm1hcChjbHVzdGVyID0+IEFycmF5LmZyb20oY2x1c3RlcikpO1xufVxuXG4vLyBCdWlsZCBkZW5kcm9ncmFtIHRyZWUgZm9yIGFnZ2xvbWVyYXRpdmUgY2x1c3RlcmluZ1xuZnVuY3Rpb24gYnVpbGREZW5kcm9ncmFtKHN0ZXBzOiBNZXJnZVN0ZXBbXSwgcG9pbnRzOiBQb2ludFtdKTogRGVuZHJvZ3JhbU5vZGUgfCBudWxsIHtcbiAgaWYgKHN0ZXBzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gQ3JlYXRlIGxlYWYgbm9kZXMgZm9yIGVhY2ggcG9pbnRcbiAgY29uc3QgbGVhZk5vZGVzOiBEZW5kcm9ncmFtTm9kZVtdID0gcG9pbnRzLm1hcCgocCwgaWR4KSA9PiAoe1xuICAgIGhlaWdodDogMCxcbiAgICBsYWJlbDogcC5pZCxcbiAgICBpbmRpY2VzOiBbaWR4XSxcbiAgfSkpO1xuXG4gIC8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBzdGlsbCBhY3RpdmVcbiAgY29uc3QgYWN0aXZlTm9kZXMgPSBuZXcgTWFwPHN0cmluZywgRGVuZHJvZ3JhbU5vZGU+KCk7XG4gIGxlYWZOb2Rlcy5mb3JFYWNoKChub2RlLCBpZHgpID0+IHtcbiAgICBhY3RpdmVOb2Rlcy5zZXQoYGxlYWZfJHtpZHh9YCwgbm9kZSk7XG4gIH0pO1xuXG4gIC8vIFByb2Nlc3MgbWVyZ2Ugc3RlcHMgdG8gYnVpbGQgdGhlIHRyZWVcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGVwcy5sZW5ndGggLSAxOyBpKyspIHsgLy8gU2tpcCBmaXJzdCBhbmQgbGFzdCBzdGVwc1xuICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tpXTtcbiAgICBpZiAoc3RlcC5hY3Rpb24gPT09ICdjb21wbGV0ZScpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluZCB0aGUgbm9kZXMgY29ycmVzcG9uZGluZyB0byB0aGUgY2x1c3RlcnMgYmVpbmcgbWVyZ2VkXG4gICAgbGV0IG5vZGUxOiBEZW5kcm9ncmFtTm9kZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBub2RlMjogRGVuZHJvZ3JhbU5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgbm9kZTFLZXkgPSAnJztcbiAgICBsZXQgbm9kZTJLZXkgPSAnJztcblxuICAgIC8vIFNlYXJjaCBmb3Igbm9kZXMgdGhhdCBjb250YWluIHRoZSBwb2ludHMgZnJvbSB0aGUgY2x1c3RlcnNcbiAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIEFycmF5LmZyb20oYWN0aXZlTm9kZXMuZW50cmllcygpKSkge1xuICAgICAgaWYgKG5vZGUuaW5kaWNlcyAmJiBzdGVwLmNsdXN0ZXIxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBub2RlIGNvbnRhaW5zIGFueSBwb2ludCBmcm9tIGNsdXN0ZXIxXG4gICAgICAgIGNvbnN0IGhhc0NsdXN0ZXIxUG9pbnQgPSBzdGVwLmNsdXN0ZXIxLnNvbWUocG9pbnRJZHggPT4gbm9kZS5pbmRpY2VzPy5pbmNsdWRlcyhwb2ludElkeCkpO1xuICAgICAgICBpZiAoaGFzQ2x1c3RlcjFQb2ludCAmJiAhbm9kZTEpIHtcbiAgICAgICAgICBub2RlMSA9IG5vZGU7XG4gICAgICAgICAgbm9kZTFLZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmluZGljZXMgJiYgc3RlcC5jbHVzdGVyMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgbm9kZSBjb250YWlucyBhbnkgcG9pbnQgZnJvbSBjbHVzdGVyMlxuICAgICAgICBjb25zdCBoYXNDbHVzdGVyMlBvaW50ID0gc3RlcC5jbHVzdGVyMi5zb21lKHBvaW50SWR4ID0+IG5vZGUuaW5kaWNlcz8uaW5jbHVkZXMocG9pbnRJZHgpKTtcbiAgICAgICAgaWYgKGhhc0NsdXN0ZXIyUG9pbnQgJiYgIW5vZGUyKSB7XG4gICAgICAgICAgbm9kZTIgPSBub2RlO1xuICAgICAgICAgIG5vZGUyS2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUxICYmIG5vZGUyICYmIG5vZGUxS2V5ICE9PSBub2RlMktleSkge1xuICAgICAgLy8gQ3JlYXRlIG5ldyBtZXJnZWQgbm9kZVxuICAgICAgY29uc3QgbWVyZ2VkTm9kZTogRGVuZHJvZ3JhbU5vZGUgPSB7XG4gICAgICAgIGxlZnQ6IG5vZGUxLFxuICAgICAgICByaWdodDogbm9kZTIsXG4gICAgICAgIGhlaWdodDogc3RlcC5kaXN0YW5jZSxcbiAgICAgICAgaW5kaWNlczogc3RlcC5tZXJnZWRDbHVzdGVyLFxuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlIG9sZCBub2RlcyBhbmQgYWRkIG5ldyBvbmVcbiAgICAgIGFjdGl2ZU5vZGVzLmRlbGV0ZShub2RlMUtleSk7XG4gICAgICBhY3RpdmVOb2Rlcy5kZWxldGUobm9kZTJLZXkpO1xuICAgICAgYWN0aXZlTm9kZXMuc2V0KGBtZXJnZV8ke2l9YCwgbWVyZ2VkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSByb290IG5vZGUgKHNob3VsZCBiZSB0aGUgb25seSByZW1haW5pbmcgbm9kZSlcbiAgY29uc3Qgcm9vdE5vZGVzID0gQXJyYXkuZnJvbShhY3RpdmVOb2Rlcy52YWx1ZXMoKSk7XG4gIGNvbnN0IHJvb3ROb2RlID0gcm9vdE5vZGVzLmxlbmd0aCA+IDAgPyByb290Tm9kZXNbMF0gOiBudWxsO1xuICBcbiAgLy8gRW5zdXJlIGFsbCBwb2ludHMgYXJlIHJlcHJlc2VudGVkIGluIHRoZSB0cmVlXG4gIGlmIChyb290Tm9kZSkge1xuICAgIGNvbnN0IGFsbFBvaW50SWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgY29sbGVjdEFsbExhYmVscyA9IChub2RlOiBEZW5kcm9ncmFtTm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUubGFiZWwpIHtcbiAgICAgICAgYWxsUG9pbnRJZHMuYWRkKG5vZGUubGFiZWwpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUubGVmdCkgY29sbGVjdEFsbExhYmVscyhub2RlLmxlZnQpO1xuICAgICAgaWYgKG5vZGUucmlnaHQpIGNvbGxlY3RBbGxMYWJlbHMobm9kZS5yaWdodCk7XG4gICAgfTtcbiAgICBcbiAgICBjb2xsZWN0QWxsTGFiZWxzKHJvb3ROb2RlKTtcbiAgICBcbiAgICAvLyBJZiBhbnkgcG9pbnRzIGFyZSBtaXNzaW5nLCBjcmVhdGUgYSBzaW1wbGUgdHJlZSB0aGF0IGluY2x1ZGVzIHRoZW0gYWxsXG4gICAgY29uc3QgbWlzc2luZ1BvaW50cyA9IHBvaW50cy5maWx0ZXIocCA9PiAhYWxsUG9pbnRJZHMuaGFzKHAuaWQpKTtcbiAgICBpZiAobWlzc2luZ1BvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBDcmVhdGUgYSBzaW1wbGUgYmFsYW5jZWQgdHJlZSB3aXRoIGFsbCBwb2ludHNcbiAgICAgIGNvbnN0IGFsbExlYWZOb2RlcyA9IHBvaW50cy5tYXAoKHAsIGlkeCkgPT4gKHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBsYWJlbDogcC5pZCxcbiAgICAgICAgaW5kaWNlczogW2lkeF0sXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIHJldHVybiBidWlsZEJhbGFuY2VkVHJlZShhbGxMZWFmTm9kZXMsIDApO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHJvb3ROb2RlO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYnVpbGQgYSBiYWxhbmNlZCB0cmVlIGZyb20gbGVhZiBub2Rlc1xuZnVuY3Rpb24gYnVpbGRCYWxhbmNlZFRyZWUobGVhZk5vZGVzOiBEZW5kcm9ncmFtTm9kZVtdLCBzdGFydEhlaWdodDogbnVtYmVyKTogRGVuZHJvZ3JhbU5vZGUge1xuICBpZiAobGVhZk5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsZWFmTm9kZXNbMF07XG4gIH1cbiAgXG4gIGlmIChsZWFmTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlYWZOb2Rlc1swXSxcbiAgICAgIHJpZ2h0OiBsZWFmTm9kZXNbMV0sXG4gICAgICBoZWlnaHQ6IHN0YXJ0SGVpZ2h0ICsgMSxcbiAgICAgIGluZGljZXM6IFsuLi4obGVhZk5vZGVzWzBdLmluZGljZXMgfHwgW10pLCAuLi4obGVhZk5vZGVzWzFdLmluZGljZXMgfHwgW10pXSxcbiAgICB9O1xuICB9XG4gIFxuICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKGxlYWZOb2Rlcy5sZW5ndGggLyAyKTtcbiAgY29uc3QgbGVmdCA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxlYWZOb2Rlcy5zbGljZSgwLCBtaWQpLCBzdGFydEhlaWdodCArIDEpO1xuICBjb25zdCByaWdodCA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxlYWZOb2Rlcy5zbGljZShtaWQpLCBzdGFydEhlaWdodCArIDEpO1xuICBcbiAgcmV0dXJuIHtcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyAxLFxuICAgIGluZGljZXM6IFsuLi4obGVmdC5pbmRpY2VzIHx8IFtdKSwgLi4uKHJpZ2h0LmluZGljZXMgfHwgW10pXSxcbiAgfTtcbn1cblxuLy8gQnVpbGQgZGVuZHJvZ3JhbSB0cmVlIGZvciBkaXZpc2l2ZSBjbHVzdGVyaW5nXG5mdW5jdGlvbiBidWlsZERpdmlzaXZlRGVuZHJvZ3JhbShzdGVwczogTWVyZ2VTdGVwW10sIHBvaW50czogUG9pbnRbXSk6IERlbmRyb2dyYW1Ob2RlIHwgbnVsbCB7XG4gIGlmIChzdGVwcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIC8vIFN0YXJ0IHdpdGggcm9vdCBub2RlIGNvbnRhaW5pbmcgYWxsIHBvaW50c1xuICBjb25zdCByb290Tm9kZTogRGVuZHJvZ3JhbU5vZGUgPSB7XG4gICAgaGVpZ2h0OiAwLFxuICAgIGluZGljZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IHBvaW50cy5sZW5ndGggfSwgKF8sIGkpID0+IGkpLFxuICB9O1xuXG4gIC8vIFByb2Nlc3MgZGl2aXNpb24gc3RlcHMgdG8gYnVpbGQgdGhlIHRyZWVcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBEZW5kcm9ncmFtTm9kZT4oKTtcbiAgbm9kZU1hcC5zZXQoJ3Jvb3QnLCByb290Tm9kZSk7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGVwcy5sZW5ndGggLSAxOyBpKyspIHsgLy8gU2tpcCBmaXJzdCBhbmQgbGFzdCBzdGVwc1xuICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tpXTtcbiAgICBpZiAoc3RlcC5hY3Rpb24gPT09ICdjb21wbGV0ZScpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluZCB0aGUgbm9kZSB0byBzcGxpdFxuICAgIGNvbnN0IG5vZGVUb1NwbGl0ID0gQXJyYXkuZnJvbShub2RlTWFwLnZhbHVlcygpKS5maW5kKG5vZGUgPT4gXG4gICAgICBub2RlLmluZGljZXMgJiYgXG4gICAgICBzdGVwLm1lcmdlZENsdXN0ZXIubGVuZ3RoID4gMCAmJiBcbiAgICAgIG5vZGUuaW5kaWNlcy5pbmNsdWRlcyhzdGVwLm1lcmdlZENsdXN0ZXJbMF0pXG4gICAgKTtcblxuICAgIGlmIChub2RlVG9TcGxpdCkge1xuICAgICAgLy8gQ3JlYXRlIGNoaWxkIG5vZGVzXG4gICAgICBjb25zdCBsZWZ0Tm9kZTogRGVuZHJvZ3JhbU5vZGUgPSB7XG4gICAgICAgIGhlaWdodDogc3RlcC5kaXN0YW5jZSxcbiAgICAgICAgaW5kaWNlczogc3RlcC5jbHVzdGVyMSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJpZ2h0Tm9kZTogRGVuZHJvZ3JhbU5vZGUgPSB7XG4gICAgICAgIGhlaWdodDogc3RlcC5kaXN0YW5jZSxcbiAgICAgICAgaW5kaWNlczogc3RlcC5jbHVzdGVyMixcbiAgICAgIH07XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyZW50IG5vZGVcbiAgICAgIG5vZGVUb1NwbGl0LmxlZnQgPSBsZWZ0Tm9kZTtcbiAgICAgIG5vZGVUb1NwbGl0LnJpZ2h0ID0gcmlnaHROb2RlO1xuICAgICAgbm9kZVRvU3BsaXQuaGVpZ2h0ID0gc3RlcC5kaXN0YW5jZTtcblxuICAgICAgLy8gQWRkIGNoaWxkIG5vZGVzIHRvIG1hcFxuICAgICAgbm9kZU1hcC5zZXQoYGxlZnRfJHtpfWAsIGxlZnROb2RlKTtcbiAgICAgIG5vZGVNYXAuc2V0KGByaWdodF8ke2l9YCwgcmlnaHROb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgbGVhZiBub2RlcyBmb3IgaW5kaXZpZHVhbCBwb2ludHNcbiAgY29uc3QgYWRkTGVhZk5vZGVzID0gKG5vZGU6IERlbmRyb2dyYW1Ob2RlKSA9PiB7XG4gICAgaWYgKG5vZGUuaW5kaWNlcyAmJiBub2RlLmluZGljZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwb2ludElkeCA9IG5vZGUuaW5kaWNlc1swXTtcbiAgICAgIG5vZGUubGFiZWwgPSBwb2ludHNbcG9pbnRJZHhdPy5pZDtcbiAgICAgIG5vZGUuaGVpZ2h0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUubGVmdCkgYWRkTGVhZk5vZGVzKG5vZGUubGVmdCk7XG4gICAgICBpZiAobm9kZS5yaWdodCkgYWRkTGVhZk5vZGVzKG5vZGUucmlnaHQpO1xuICAgIH1cbiAgfTtcblxuICBhZGRMZWFmTm9kZXMocm9vdE5vZGUpO1xuICBcbiAgLy8gRW5zdXJlIGFsbCBwb2ludHMgYXJlIHJlcHJlc2VudGVkIGFzIGxlYWYgbm9kZXNcbiAgY29uc3QgYWxsUG9pbnRJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgY29sbGVjdExlYWZMYWJlbHMgPSAobm9kZTogRGVuZHJvZ3JhbU5vZGUpID0+IHtcbiAgICBpZiAobm9kZS5sYWJlbCkge1xuICAgICAgYWxsUG9pbnRJZHMuYWRkKG5vZGUubGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5sZWZ0KSBjb2xsZWN0TGVhZkxhYmVscyhub2RlLmxlZnQpO1xuICAgICAgaWYgKG5vZGUucmlnaHQpIGNvbGxlY3RMZWFmTGFiZWxzKG5vZGUucmlnaHQpO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbGxlY3RMZWFmTGFiZWxzKHJvb3ROb2RlKTtcbiAgXG4gIC8vIElmIGFueSBwb2ludHMgYXJlIG1pc3NpbmcsIGNyZWF0ZSBhIGNvbXBsZXRlIHRyZWUgd2l0aCBhbGwgcG9pbnRzXG4gIGNvbnN0IG1pc3NpbmdQb2ludHMgPSBwb2ludHMuZmlsdGVyKHAgPT4gIWFsbFBvaW50SWRzLmhhcyhwLmlkKSk7XG4gIGlmIChtaXNzaW5nUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgYmFsYW5jZWQgdHJlZSB3aXRoIGFsbCBwb2ludHNcbiAgICBjb25zdCBhbGxMZWFmTm9kZXMgPSBwb2ludHMubWFwKChwLCBpZHgpID0+ICh7XG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsYWJlbDogcC5pZCxcbiAgICAgIGluZGljZXM6IFtpZHhdLFxuICAgIH0pKTtcbiAgICBcbiAgICByZXR1cm4gYnVpbGRCYWxhbmNlZFRyZWUoYWxsTGVhZk5vZGVzLCAwKTtcbiAgfVxuICBcbiAgcmV0dXJuIHJvb3ROb2RlO1xufVxuIl0sIm5hbWVzIjpbImV1Y2xpZGVhbkRpc3RhbmNlIiwicDEiLCJwMiIsIk1hdGgiLCJzcXJ0IiwieCIsInkiLCJjbHVzdGVyRGlzdGFuY2UiLCJjMSIsImMyIiwicG9pbnRzIiwidG90YWxEaXN0YW5jZSIsImNvdW50IiwiaSIsImoiLCJJbmZpbml0eSIsImdldENsdXN0ZXJDZW50ZXIiLCJjbHVzdGVyIiwic3VtWCIsInN1bVkiLCJpZHgiLCJhZ2dsb21lcmF0aXZlQ2x1c3RlcmluZyIsInN0ZXBzIiwiY2x1c3RlcnMiLCJtYXAiLCJwIiwiY2VudGVyIiwic3RlcE51bWJlciIsInB1c2giLCJkZXNjcmlwdGlvbiIsImxlbmd0aCIsImNsdXN0ZXIxIiwiY2x1c3RlcjIiLCJtZXJnZWRDbHVzdGVyIiwiZGlzdGFuY2UiLCJhY3Rpb24iLCJkaXN0YW5jZU1hdHJpeCIsImFjdGl2ZUNsdXN0ZXJzIiwiU2V0IiwiYWRkIiwic2l6ZSIsIm1pbkRpc3RhbmNlIiwibWVyZ2VJIiwibWVyZ2VKIiwiYWN0aXZlQXJyYXkiLCJBcnJheSIsImZyb20iLCJjbHVzdGVySSIsImNsdXN0ZXJKIiwiZGlzdCIsIm1lcmdlZFBvaW50cyIsImlkIiwidG9GaXhlZCIsIm5ld0NsdXN0ZXJJbmRleCIsImRlbGV0ZSIsImRlbmRyb2dyYW0iLCJidWlsZERlbmRyb2dyYW0iLCJmaW5hbENsdXN0ZXJzIiwiZ2V0RmluYWxDbHVzdGVycyIsImRpdmlzaXZlQ2x1c3RlcmluZyIsIl8iLCJtaW4iLCJtYXhTaXplIiwic3BsaXRJZHgiLCJmb3JFYWNoIiwiY2x1c3RlclRvU3BsaXQiLCJzcGxpdENsdXN0ZXIiLCJzcGxpY2UiLCJidWlsZERpdmlzaXZlRGVuZHJvZ3JhbSIsImMiLCJpbmRpY2VzIiwiYzFJZHgiLCJjMklkeCIsImZsb29yIiwiY2VudHJvaWQxIiwiY2VudHJvaWQyIiwiYXNzaWdubWVudCIsImZpbGwiLCJjaGFuZ2VkIiwiaXRlcmF0aW9ucyIsImRpc3QxIiwiZGlzdDIiLCJuZXdBc3NpZ25tZW50IiwiZ3JvdXAxIiwiZmlsdGVyIiwiZ3JvdXAyIiwicmVkdWNlIiwic3VtIiwiZGF0YSIsIm51bVBvaW50cyIsInRhcmdldENsdXN0ZXJzIiwidGFyZ2V0U3RlcCIsIm1heCIsInBvaW50VG9DbHVzdGVyIiwiTWFwIiwic2V0Iiwic3RlcCIsImNsdXN0ZXIxSWQiLCJnZXQiLCJjbHVzdGVyMklkIiwidW5kZWZpbmVkIiwiY2x1c3RlcjFQb2ludHMiLCJjbHVzdGVyMlBvaW50cyIsInBvaW50IiwidmFsdWVzIiwibGVhZk5vZGVzIiwiaGVpZ2h0IiwibGFiZWwiLCJhY3RpdmVOb2RlcyIsIm5vZGUiLCJub2RlMSIsIm5vZGUyIiwibm9kZTFLZXkiLCJub2RlMktleSIsImtleSIsImVudHJpZXMiLCJoYXNDbHVzdGVyMVBvaW50Iiwic29tZSIsInBvaW50SWR4IiwiaW5jbHVkZXMiLCJoYXNDbHVzdGVyMlBvaW50IiwibWVyZ2VkTm9kZSIsImxlZnQiLCJyaWdodCIsInJvb3ROb2RlcyIsInJvb3ROb2RlIiwiYWxsUG9pbnRJZHMiLCJjb2xsZWN0QWxsTGFiZWxzIiwibWlzc2luZ1BvaW50cyIsImhhcyIsImFsbExlYWZOb2RlcyIsImJ1aWxkQmFsYW5jZWRUcmVlIiwic3RhcnRIZWlnaHQiLCJtaWQiLCJzbGljZSIsIm5vZGVNYXAiLCJub2RlVG9TcGxpdCIsImZpbmQiLCJsZWZ0Tm9kZSIsInJpZ2h0Tm9kZSIsImFkZExlYWZOb2RlcyIsImNvbGxlY3RMZWFmTGFiZWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/lib/clustering.ts\n");

/***/ }),

/***/ "(rsc)/./shared/schema.ts":
/*!**************************!*\
  !*** ./shared/schema.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clusterRequestSchema: () => (/* binding */ clusterRequestSchema),\n/* harmony export */   clusterResponseSchema: () => (/* binding */ clusterResponseSchema),\n/* harmony export */   crimeSiteSchema: () => (/* binding */ crimeSiteSchema),\n/* harmony export */   customerSchema: () => (/* binding */ customerSchema),\n/* harmony export */   medicalPatientSchema: () => (/* binding */ medicalPatientSchema)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n\n// Medical Patient Dataset\nconst medicalPatientSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    Patient_ID: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    Age: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Temperature_F: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Blood_Pressure_Sys: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Blood_Pressure_Dia: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Sugar_Level_mg_dL: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Symptoms: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()\n});\n// Crime Site Dataset\nconst crimeSiteSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    Crime_ID: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    Latitude: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Longitude: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Crime_Type: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    Time_of_Day: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    Severity_Level: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Reported_By: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()\n});\n// Customer Segmentation Dataset\nconst customerSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    Customer_ID: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),\n    Age: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Annual_Income_kUSD: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Spending_Score: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Loyalty_Years: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n    Preferred_Category: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()\n});\n// Clustering Request/Response\nconst clusterRequestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    dataset: zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([\n        \"medical\",\n        \"crime\",\n        \"customer\"\n    ]),\n    algorithm: zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([\n        \"agglomerative\",\n        \"divisive\"\n    ]),\n    dataPoints: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n        x: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n        y: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),\n        data: zod__WEBPACK_IMPORTED_MODULE_0__.z.any()\n    })),\n    numClusters: zod__WEBPACK_IMPORTED_MODULE_0__.z.number().optional()\n});\nconst clusterResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({\n    steps: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.any()),\n    finalClusters: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.number())),\n    dendrogram: zod__WEBPACK_IMPORTED_MODULE_0__.z.any()\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zaGFyZWQvc2NoZW1hLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QjtBQUV4QiwwQkFBMEI7QUFDbkIsTUFBTUMsdUJBQXVCRCxrQ0FBQ0EsQ0FBQ0UsTUFBTSxDQUFDO0lBQzNDQyxZQUFZSCxrQ0FBQ0EsQ0FBQ0ksTUFBTTtJQUNwQkMsS0FBS0wsa0NBQUNBLENBQUNNLE1BQU07SUFDYkMsZUFBZVAsa0NBQUNBLENBQUNNLE1BQU07SUFDdkJFLG9CQUFvQlIsa0NBQUNBLENBQUNNLE1BQU07SUFDNUJHLG9CQUFvQlQsa0NBQUNBLENBQUNNLE1BQU07SUFDNUJJLG1CQUFtQlYsa0NBQUNBLENBQUNNLE1BQU07SUFDM0JLLFVBQVVYLGtDQUFDQSxDQUFDSSxNQUFNO0FBQ3BCLEdBQUc7QUFJSCxxQkFBcUI7QUFDZCxNQUFNUSxrQkFBa0JaLGtDQUFDQSxDQUFDRSxNQUFNLENBQUM7SUFDdENXLFVBQVViLGtDQUFDQSxDQUFDSSxNQUFNO0lBQ2xCVSxVQUFVZCxrQ0FBQ0EsQ0FBQ00sTUFBTTtJQUNsQlMsV0FBV2Ysa0NBQUNBLENBQUNNLE1BQU07SUFDbkJVLFlBQVloQixrQ0FBQ0EsQ0FBQ0ksTUFBTTtJQUNwQmEsYUFBYWpCLGtDQUFDQSxDQUFDSSxNQUFNO0lBQ3JCYyxnQkFBZ0JsQixrQ0FBQ0EsQ0FBQ00sTUFBTTtJQUN4QmEsYUFBYW5CLGtDQUFDQSxDQUFDSSxNQUFNO0FBQ3ZCLEdBQUc7QUFJSCxnQ0FBZ0M7QUFDekIsTUFBTWdCLGlCQUFpQnBCLGtDQUFDQSxDQUFDRSxNQUFNLENBQUM7SUFDckNtQixhQUFhckIsa0NBQUNBLENBQUNJLE1BQU07SUFDckJDLEtBQUtMLGtDQUFDQSxDQUFDTSxNQUFNO0lBQ2JnQixvQkFBb0J0QixrQ0FBQ0EsQ0FBQ00sTUFBTTtJQUM1QmlCLGdCQUFnQnZCLGtDQUFDQSxDQUFDTSxNQUFNO0lBQ3hCa0IsZUFBZXhCLGtDQUFDQSxDQUFDTSxNQUFNO0lBQ3ZCbUIsb0JBQW9CekIsa0NBQUNBLENBQUNJLE1BQU07QUFDOUIsR0FBRztBQWlDSCw4QkFBOEI7QUFDdkIsTUFBTXNCLHVCQUF1QjFCLGtDQUFDQSxDQUFDRSxNQUFNLENBQUM7SUFDM0N5QixTQUFTM0Isa0NBQUNBLENBQUM0QixJQUFJLENBQUM7UUFBQztRQUFXO1FBQVM7S0FBVztJQUNoREMsV0FBVzdCLGtDQUFDQSxDQUFDNEIsSUFBSSxDQUFDO1FBQUM7UUFBaUI7S0FBVztJQUMvQ0UsWUFBWTlCLGtDQUFDQSxDQUFDK0IsS0FBSyxDQUFDL0Isa0NBQUNBLENBQUNFLE1BQU0sQ0FBQztRQUMzQjhCLEdBQUdoQyxrQ0FBQ0EsQ0FBQ00sTUFBTTtRQUNYMkIsR0FBR2pDLGtDQUFDQSxDQUFDTSxNQUFNO1FBQ1g0QixNQUFNbEMsa0NBQUNBLENBQUNtQyxHQUFHO0lBQ2I7SUFDQUMsYUFBYXBDLGtDQUFDQSxDQUFDTSxNQUFNLEdBQUcrQixRQUFRO0FBQ2xDLEdBQUc7QUFJSSxNQUFNQyx3QkFBd0J0QyxrQ0FBQ0EsQ0FBQ0UsTUFBTSxDQUFDO0lBQzVDcUMsT0FBT3ZDLGtDQUFDQSxDQUFDK0IsS0FBSyxDQUFDL0Isa0NBQUNBLENBQUNtQyxHQUFHO0lBQ3BCSyxlQUFleEMsa0NBQUNBLENBQUMrQixLQUFLLENBQUMvQixrQ0FBQ0EsQ0FBQytCLEtBQUssQ0FBQy9CLGtDQUFDQSxDQUFDTSxNQUFNO0lBQ3ZDbUMsWUFBWXpDLGtDQUFDQSxDQUFDbUMsR0FBRztBQUNuQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGllcmFyY2hpY2FsLWNsdXN0ZXJpbmctdmlzdWFsaXphdGlvbi8uL3NoYXJlZC9zY2hlbWEudHM/MWI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xyXG5cclxuLy8gTWVkaWNhbCBQYXRpZW50IERhdGFzZXRcclxuZXhwb3J0IGNvbnN0IG1lZGljYWxQYXRpZW50U2NoZW1hID0gei5vYmplY3Qoe1xyXG4gIFBhdGllbnRfSUQ6IHouc3RyaW5nKCksXHJcbiAgQWdlOiB6Lm51bWJlcigpLFxyXG4gIFRlbXBlcmF0dXJlX0Y6IHoubnVtYmVyKCksXHJcbiAgQmxvb2RfUHJlc3N1cmVfU3lzOiB6Lm51bWJlcigpLFxyXG4gIEJsb29kX1ByZXNzdXJlX0RpYTogei5udW1iZXIoKSxcclxuICBTdWdhcl9MZXZlbF9tZ19kTDogei5udW1iZXIoKSxcclxuICBTeW1wdG9tczogei5zdHJpbmcoKSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBNZWRpY2FsUGF0aWVudCA9IHouaW5mZXI8dHlwZW9mIG1lZGljYWxQYXRpZW50U2NoZW1hPjtcclxuXHJcbi8vIENyaW1lIFNpdGUgRGF0YXNldFxyXG5leHBvcnQgY29uc3QgY3JpbWVTaXRlU2NoZW1hID0gei5vYmplY3Qoe1xyXG4gIENyaW1lX0lEOiB6LnN0cmluZygpLFxyXG4gIExhdGl0dWRlOiB6Lm51bWJlcigpLFxyXG4gIExvbmdpdHVkZTogei5udW1iZXIoKSxcclxuICBDcmltZV9UeXBlOiB6LnN0cmluZygpLFxyXG4gIFRpbWVfb2ZfRGF5OiB6LnN0cmluZygpLFxyXG4gIFNldmVyaXR5X0xldmVsOiB6Lm51bWJlcigpLFxyXG4gIFJlcG9ydGVkX0J5OiB6LnN0cmluZygpLFxyXG59KTtcclxuXHJcbmV4cG9ydCB0eXBlIENyaW1lU2l0ZSA9IHouaW5mZXI8dHlwZW9mIGNyaW1lU2l0ZVNjaGVtYT47XHJcblxyXG4vLyBDdXN0b21lciBTZWdtZW50YXRpb24gRGF0YXNldFxyXG5leHBvcnQgY29uc3QgY3VzdG9tZXJTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAgQ3VzdG9tZXJfSUQ6IHouc3RyaW5nKCksXHJcbiAgQWdlOiB6Lm51bWJlcigpLFxyXG4gIEFubnVhbF9JbmNvbWVfa1VTRDogei5udW1iZXIoKSxcclxuICBTcGVuZGluZ19TY29yZTogei5udW1iZXIoKSxcclxuICBMb3lhbHR5X1llYXJzOiB6Lm51bWJlcigpLFxyXG4gIFByZWZlcnJlZF9DYXRlZ29yeTogei5zdHJpbmcoKSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBDdXN0b21lciA9IHouaW5mZXI8dHlwZW9mIGN1c3RvbWVyU2NoZW1hPjtcclxuXHJcbi8vIEdlbmVyaWMgRGF0YSBQb2ludCBmb3Igc2NhdHRlciBwbG90XHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVBvaW50IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgZGF0YTogTWVkaWNhbFBhdGllbnQgfCBDcmltZVNpdGUgfCBDdXN0b21lcjtcclxuICBjbHVzdGVyPzogbnVtYmVyO1xyXG4gIGlzTmV3PzogYm9vbGVhbjtcclxufVxyXG5cclxuLy8gQ2x1c3RlcmluZyBTdGVwIGZvciBhbmltYXRpb25cclxuZXhwb3J0IGludGVyZmFjZSBDbHVzdGVyU3RlcCB7XHJcbiAgc3RlcE51bWJlcjogbnVtYmVyO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgY29ubmVjdGVkUGFpcnM/OiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPjsgLy8gaW5kaWNlcyBvZiBwb2ludHMgYmVpbmcgY29ubmVjdGVkXHJcbiAgbWVyZ2VkQ2x1c3RlcnM/OiBBcnJheTxudW1iZXJbXT47IC8vIGFycmF5cyBvZiBwb2ludCBpbmRpY2VzIGluIGVhY2ggY2x1c3RlclxyXG4gIGRlbmRyb2dyYW1IZWlnaHQ/OiBudW1iZXI7XHJcbiAgYWN0aW9uOiAnY29ubmVjdCcgfCAnbWVyZ2UnIHwgJ2NvbXBsZXRlJztcclxufVxyXG5cclxuLy8gQ2x1c3RlciBJbmZvIGZvciB0b29sdGlwc1xyXG5leHBvcnQgaW50ZXJmYWNlIENsdXN0ZXJJbmZvIHtcclxuICBpZDogbnVtYmVyO1xyXG4gIHBvaW50SW5kaWNlczogbnVtYmVyW107XHJcbiAgY29sb3I6IHN0cmluZztcclxuICBzdGF0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcclxuICBkaWFnbm9zaXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIENsdXN0ZXJpbmcgUmVxdWVzdC9SZXNwb25zZVxyXG5leHBvcnQgY29uc3QgY2x1c3RlclJlcXVlc3RTY2hlbWEgPSB6Lm9iamVjdCh7XHJcbiAgZGF0YXNldDogei5lbnVtKFsnbWVkaWNhbCcsICdjcmltZScsICdjdXN0b21lciddKSxcclxuICBhbGdvcml0aG06IHouZW51bShbJ2FnZ2xvbWVyYXRpdmUnLCAnZGl2aXNpdmUnXSksXHJcbiAgZGF0YVBvaW50czogei5hcnJheSh6Lm9iamVjdCh7XHJcbiAgICB4OiB6Lm51bWJlcigpLFxyXG4gICAgeTogei5udW1iZXIoKSxcclxuICAgIGRhdGE6IHouYW55KCksXHJcbiAgfSkpLFxyXG4gIG51bUNsdXN0ZXJzOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXHJcbn0pO1xyXG5cclxuZXhwb3J0IHR5cGUgQ2x1c3RlclJlcXVlc3QgPSB6LmluZmVyPHR5cGVvZiBjbHVzdGVyUmVxdWVzdFNjaGVtYT47XHJcblxyXG5leHBvcnQgY29uc3QgY2x1c3RlclJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xyXG4gIHN0ZXBzOiB6LmFycmF5KHouYW55KCkpLFxyXG4gIGZpbmFsQ2x1c3RlcnM6IHouYXJyYXkoei5hcnJheSh6Lm51bWJlcigpKSksXHJcbiAgZGVuZHJvZ3JhbTogei5hbnkoKSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBDbHVzdGVyUmVzcG9uc2UgPSB6LmluZmVyPHR5cGVvZiBjbHVzdGVyUmVzcG9uc2VTY2hlbWE+O1xyXG5cclxuLy8gRGF0YXNldCBjb25maWd1cmF0aW9uXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YXNldENvbmZpZyB7XHJcbiAgaWQ6ICdtZWRpY2FsJyB8ICdjcmltZScgfCAnY3VzdG9tZXInO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBpY29uOiBzdHJpbmc7XHJcbiAgeEF4aXM6IHsgbGFiZWw6IHN0cmluZzsga2V5OiBzdHJpbmcgfTtcclxuICB5QXhpczogeyBsYWJlbDogc3RyaW5nOyBrZXk6IHN0cmluZyB9O1xyXG4gIGF2YWlsYWJsZUF4ZXM/OiBBcnJheTx7IGxhYmVsOiBzdHJpbmc7IGtleTogc3RyaW5nOyByYW5nZTogW251bWJlciwgbnVtYmVyXSB9PjtcclxuICB0b29sdGlwRmllbGRzOiBBcnJheTx7IGxhYmVsOiBzdHJpbmc7IGtleTogc3RyaW5nOyBmb3JtYXQ/OiAodmFsOiBudW1iZXIsIGRhdGE/OiBhbnkpID0+IHN0cmluZyB9PjtcclxuICBjbHVzdGVyQ29sb3JzOiBzdHJpbmdbXTtcclxuICBnZXREaWFnbm9zaXM/OiAoc3RhdHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4pID0+IHN0cmluZztcclxuICBnZXRTdG9yeVN0ZXA/OiAoc3RlcDogbnVtYmVyLCBhbGdvcml0aG06ICdhZ2dsb21lcmF0aXZlJyB8ICdkaXZpc2l2ZScpID0+IHN0cmluZztcclxufVxyXG4iXSwibmFtZXMiOlsieiIsIm1lZGljYWxQYXRpZW50U2NoZW1hIiwib2JqZWN0IiwiUGF0aWVudF9JRCIsInN0cmluZyIsIkFnZSIsIm51bWJlciIsIlRlbXBlcmF0dXJlX0YiLCJCbG9vZF9QcmVzc3VyZV9TeXMiLCJCbG9vZF9QcmVzc3VyZV9EaWEiLCJTdWdhcl9MZXZlbF9tZ19kTCIsIlN5bXB0b21zIiwiY3JpbWVTaXRlU2NoZW1hIiwiQ3JpbWVfSUQiLCJMYXRpdHVkZSIsIkxvbmdpdHVkZSIsIkNyaW1lX1R5cGUiLCJUaW1lX29mX0RheSIsIlNldmVyaXR5X0xldmVsIiwiUmVwb3J0ZWRfQnkiLCJjdXN0b21lclNjaGVtYSIsIkN1c3RvbWVyX0lEIiwiQW5udWFsX0luY29tZV9rVVNEIiwiU3BlbmRpbmdfU2NvcmUiLCJMb3lhbHR5X1llYXJzIiwiUHJlZmVycmVkX0NhdGVnb3J5IiwiY2x1c3RlclJlcXVlc3RTY2hlbWEiLCJkYXRhc2V0IiwiZW51bSIsImFsZ29yaXRobSIsImRhdGFQb2ludHMiLCJhcnJheSIsIngiLCJ5IiwiZGF0YSIsImFueSIsIm51bUNsdXN0ZXJzIiwib3B0aW9uYWwiLCJjbHVzdGVyUmVzcG9uc2VTY2hlbWEiLCJzdGVwcyIsImZpbmFsQ2x1c3RlcnMiLCJkZW5kcm9ncmFtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./shared/schema.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/zod"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcluster%2Froute&page=%2Fapi%2Fcluster%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcluster%2Froute.ts&appDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CSANJAY%5CDownloads%5CDharmik%5CDHV%5CDHV-project-2&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();