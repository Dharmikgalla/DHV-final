"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_App_tsx",{

/***/ "(app-pages-browser)/./app/components/ScatterPlot.tsx":
/*!****************************************!*\
  !*** ./app/components/ScatterPlot.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScatterPlot: function() { return /* binding */ ScatterPlot; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=MapPin,ShoppingBag,User!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js\");\n/* harmony import */ var _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=MapPin,ShoppingBag,User!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/map-pin.js\");\n/* harmony import */ var _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=MapPin,ShoppingBag,User!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/shopping-bag.js\");\n\nvar _s = $RefreshSig$();\n\n\nfunction ScatterPlot(param) {\n    let { dataPoints, clusters, connections, datasetType, xLabel, yLabel, xRange, yRange, onAddPoint, onPointHover, onClusterHover, addMode } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [hoveredPoint, setHoveredPoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredCluster, setHoveredCluster] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 800,\n        height: 600\n    });\n    const [mousePos, setMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const padding = {\n        top: 40,\n        right: 40,\n        bottom: 60,\n        left: 70\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (containerRef.current) {\n                const { width } = containerRef.current.getBoundingClientRect();\n                setDimensions({\n                    width,\n                    height: Math.max(500, width * 0.75)\n                });\n            }\n        };\n        updateDimensions();\n        window.addEventListener(\"resize\", updateDimensions);\n        return ()=>window.removeEventListener(\"resize\", updateDimensions);\n    }, []);\n    const getScales = ()=>{\n        if (xRange && yRange) {\n            // Use provided ranges\n            return {\n                xMin: xRange[0],\n                xMax: xRange[1],\n                yMin: yRange[0],\n                yMax: yRange[1]\n            };\n        }\n        // Fallback to data-based scaling\n        const xValues = dataPoints.map((p)=>p.x);\n        const yValues = dataPoints.map((p)=>p.y);\n        const xMin = Math.min(...xValues);\n        const xMax = Math.max(...xValues);\n        const yMin = Math.min(...yValues);\n        const yMax = Math.max(...yValues);\n        const xRange = xMax - xMin || 1;\n        const yRange = yMax - yMin || 1;\n        return {\n            xMin: xMin - xRange * 0.1,\n            xMax: xMax + xRange * 0.1,\n            yMin: yMin - yRange * 0.1,\n            yMax: yMax + yRange * 0.1\n        };\n    };\n    const scaleX = (x)=>{\n        const scales = getScales();\n        return padding.left + (x - scales.xMin) / (scales.xMax - scales.xMin) * (dimensions.width - padding.left - padding.right);\n    };\n    const scaleY = (y)=>{\n        const scales = getScales();\n        return dimensions.height - padding.bottom - (y - scales.yMin) / (scales.yMax - scales.yMin) * (dimensions.height - padding.top - padding.bottom);\n    };\n    const inverseScaleX = (px)=>{\n        const scales = getScales();\n        return scales.xMin + (px - padding.left) / (dimensions.width - padding.left - padding.right) * (scales.xMax - scales.xMin);\n    };\n    const inverseScaleY = (px)=>{\n        const scales = getScales();\n        return scales.yMin + (dimensions.height - padding.bottom - px) / (dimensions.height - padding.top - padding.bottom) * (scales.yMax - scales.yMin);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const dpr = window.devicePixelRatio || 1;\n        canvas.width = dimensions.width * dpr;\n        canvas.height = dimensions.height * dpr;\n        canvas.style.width = \"\".concat(dimensions.width, \"px\");\n        canvas.style.height = \"\".concat(dimensions.height, \"px\");\n        ctx.scale(dpr, dpr);\n        ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n        // Draw grid\n        ctx.strokeStyle = \"hsl(var(--border))\";\n        ctx.lineWidth = 0.5;\n        ctx.globalAlpha = 0.3;\n        for(let i = 0; i <= 10; i++){\n            const x = padding.left + i / 10 * (dimensions.width - padding.left - padding.right);\n            const y = padding.top + i / 10 * (dimensions.height - padding.top - padding.bottom);\n            ctx.beginPath();\n            ctx.moveTo(x, padding.top);\n            ctx.lineTo(x, dimensions.height - padding.bottom);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.moveTo(padding.left, y);\n            ctx.lineTo(dimensions.width - padding.right, y);\n            ctx.stroke();\n        }\n        ctx.globalAlpha = 1;\n        // Draw clusters\n        clusters.forEach((cluster, idx)=>{\n            if (cluster.pointIndices.length === 0) return;\n            const points = cluster.pointIndices.map((i)=>dataPoints[i]).filter(Boolean);\n            if (points.length === 0) return;\n            const xs = points.map((p)=>scaleX(p.x));\n            const ys = points.map((p)=>scaleY(p.y));\n            const centerX = xs.reduce((a, b)=>a + b, 0) / xs.length;\n            const centerY = ys.reduce((a, b)=>a + b, 0) / ys.length;\n            const maxDist = Math.max(...xs.map((x, i)=>Math.sqrt((x - centerX) ** 2 + (ys[i] - centerY) ** 2)));\n            const radius = maxDist + 30;\n            ctx.fillStyle = cluster.color.replace(\"hsl\", \"hsla\").replace(\")\", \", 0.08)\");\n            ctx.strokeStyle = cluster.color;\n            ctx.lineWidth = 3;\n            if (hoveredCluster === idx) {\n                ctx.fillStyle = cluster.color.replace(\"hsl\", \"hsla\").replace(\")\", \", 0.15)\");\n                ctx.shadowColor = cluster.color;\n                ctx.shadowBlur = 15;\n            }\n            ctx.beginPath();\n            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.stroke();\n            ctx.shadowBlur = 0;\n        });\n        // Draw connections\n        ctx.strokeStyle = \"hsl(var(--primary))\";\n        ctx.lineWidth = 2;\n        ctx.globalAlpha = 0.6;\n        ctx.setLineDash([\n            4,\n            4\n        ]);\n        connections.forEach((param)=>{\n            let [i, j] = param;\n            const p1 = dataPoints[i];\n            const p2 = dataPoints[j];\n            if (!p1 || !p2) return;\n            ctx.beginPath();\n            ctx.moveTo(scaleX(p1.x), scaleY(p1.y));\n            ctx.lineTo(scaleX(p2.x), scaleY(p2.y));\n            ctx.stroke();\n        });\n        ctx.setLineDash([]);\n        ctx.globalAlpha = 1;\n        // Draw axes\n        ctx.strokeStyle = \"hsl(var(--foreground))\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(padding.left, padding.top);\n        ctx.lineTo(padding.left, dimensions.height - padding.bottom);\n        ctx.lineTo(dimensions.width - padding.right, dimensions.height - padding.bottom);\n        ctx.stroke();\n        // Draw axis labels\n        ctx.fillStyle = \"hsl(var(--foreground))\";\n        ctx.font = \"14px Inter\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(xLabel, dimensions.width / 2, dimensions.height - 20);\n        ctx.save();\n        ctx.translate(20, dimensions.height / 2);\n        ctx.rotate(-Math.PI / 2);\n        ctx.fillText(yLabel, 0, 0);\n        ctx.restore();\n    }, [\n        dataPoints,\n        clusters,\n        connections,\n        dimensions,\n        xLabel,\n        yLabel,\n        hoveredCluster\n    ]);\n    const handleMouseMove = (e)=>{\n        var _containerRef_current;\n        const rect = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect();\n        if (!rect) return;\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        setMousePos({\n            x,\n            y\n        });\n        // Check for hovered points\n        let foundPoint = false;\n        for(let i = 0; i < dataPoints.length; i++){\n            const px = scaleX(dataPoints[i].x);\n            const py = scaleY(dataPoints[i].y);\n            const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);\n            if (dist < 15) {\n                setHoveredPoint(i);\n                onPointHover === null || onPointHover === void 0 ? void 0 : onPointHover(dataPoints[i]);\n                foundPoint = true;\n                break;\n            }\n        }\n        if (!foundPoint) {\n            setHoveredPoint(null);\n            onPointHover === null || onPointHover === void 0 ? void 0 : onPointHover(null);\n        }\n        // Check for hovered clusters\n        let foundCluster = false;\n        clusters.forEach((cluster, idx)=>{\n            if (cluster.pointIndices.length === 0) return;\n            const points = cluster.pointIndices.map((i)=>dataPoints[i]).filter(Boolean);\n            if (points.length === 0) return;\n            const xs = points.map((p)=>scaleX(p.x));\n            const ys = points.map((p)=>scaleY(p.y));\n            const centerX = xs.reduce((a, b)=>a + b, 0) / xs.length;\n            const centerY = ys.reduce((a, b)=>a + b, 0) / ys.length;\n            const maxDist = Math.max(...xs.map((x, i)=>Math.sqrt((x - centerX) ** 2 + (ys[i] - centerY) ** 2)));\n            const radius = maxDist + 30;\n            const dist = Math.sqrt((centerX - x) ** 2 + (centerY - y) ** 2);\n            if (dist < radius && !foundPoint) {\n                setHoveredCluster(idx);\n                onClusterHover === null || onClusterHover === void 0 ? void 0 : onClusterHover(cluster);\n                foundCluster = true;\n            }\n        });\n        if (!foundCluster) {\n            setHoveredCluster(null);\n            if (!foundPoint) onClusterHover === null || onClusterHover === void 0 ? void 0 : onClusterHover(null);\n        }\n    };\n    const handleClick = (e)=>{\n        var _containerRef_current;\n        if (!addMode || !onAddPoint) return;\n        const rect = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect();\n        if (!rect) return;\n        const clickX = e.clientX - rect.left;\n        const clickY = e.clientY - rect.top;\n        // Check if clicked within plot area\n        if (clickX >= padding.left && clickX <= dimensions.width - padding.right && clickY >= padding.top && clickY <= dimensions.height - padding.bottom) {\n            const dataX = inverseScaleX(clickX);\n            const dataY = inverseScaleY(clickY);\n            onAddPoint(dataX, dataY);\n        }\n    };\n    const IconComponent = datasetType === \"medical\" ? _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : datasetType === \"crime\" ? _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"] : _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"relative w-full bg-card rounded-md border border-card-border overflow-visible\",\n        onMouseMove: handleMouseMove,\n        onMouseLeave: ()=>{\n            setHoveredPoint(null);\n            setHoveredCluster(null);\n            onPointHover === null || onPointHover === void 0 ? void 0 : onPointHover(null);\n            onClusterHover === null || onClusterHover === void 0 ? void 0 : onClusterHover(null);\n        },\n        onClick: handleClick,\n        style: {\n            cursor: addMode ? \"crosshair\" : \"default\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: \"w-full\"\n            }, void 0, false, {\n                fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                lineNumber: 327,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                className: \"absolute top-0 left-0 pointer-events-none\",\n                width: dimensions.width,\n                height: dimensions.height,\n                style: {\n                    overflow: \"visible\"\n                },\n                children: [\n                    dataPoints.map((point, idx)=>{\n                        const x = scaleX(point.x);\n                        const y = scaleY(point.y);\n                        const isHovered = hoveredPoint === idx;\n                        const cluster = clusters.find((c)=>c.pointIndices.includes(idx));\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n                            children: [\n                                isHovered && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    r: 18,\n                                    fill: \"none\",\n                                    stroke: \"hsl(var(--primary))\",\n                                    strokeWidth: 2,\n                                    opacity: 0.5,\n                                    className: \"animate-pulse\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                    lineNumber: 345,\n                                    columnNumber: 17\n                                }, this),\n                                point.isNew && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    r: 20,\n                                    fill: \"none\",\n                                    stroke: \"hsl(var(--chart-5))\",\n                                    strokeWidth: 3,\n                                    opacity: 0.7,\n                                    className: \"animate-pulse\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                    lineNumber: 355,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"foreignObject\", {\n                                    x: -12,\n                                    y: -12,\n                                    width: 24,\n                                    height: 24,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                                        className: \"w-6 h-6 transition-all \".concat(isHovered ? \"scale-125\" : \"\"),\n                                        style: {\n                                            color: cluster ? cluster.color : \"hsl(var(--foreground))\",\n                                            filter: isHovered ? \"drop-shadow(0 0 4px currentColor)\" : \"none\"\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                        lineNumber: 365,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                    lineNumber: 364,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, point.id, true, {\n                            fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                            lineNumber: 343,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    addMode && mousePos.x > padding.left && mousePos.x < dimensions.width - padding.right && mousePos.y > padding.top && mousePos.y < dimensions.height - padding.bottom && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(mousePos.x, \", \").concat(mousePos.y, \")\"),\n                        opacity: 0.5,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"foreignObject\", {\n                            x: -12,\n                            y: -12,\n                            width: 24,\n                            height: 24,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                                className: \"w-6 h-6\",\n                                style: {\n                                    color: \"hsl(var(--primary))\"\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                lineNumber: 382,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                            lineNumber: 381,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                        lineNumber: 380,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                lineNumber: 330,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n        lineNumber: 314,\n        columnNumber: 5\n    }, this);\n}\n_s(ScatterPlot, \"LpbhOkUcx6hnHiX2KWTRe/uzCPs=\");\n_c = ScatterPlot;\nvar _c;\n$RefreshReg$(_c, \"ScatterPlot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1NjYXR0ZXJQbG90LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb0Q7QUFFSztBQWlCbEQsU0FBU00sWUFBWSxLQWFUO1FBYlMsRUFDMUJDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsTUFBTSxFQUNOQyxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxVQUFVLEVBQ1ZDLFlBQVksRUFDWkMsY0FBYyxFQUNkQyxPQUFPLEVBQ1UsR0FiUzs7SUFjMUIsTUFBTUMsWUFBWWxCLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNbUIsZUFBZW5CLDZDQUFNQSxDQUFpQjtJQUM1QyxNQUFNLENBQUNvQixjQUFjQyxnQkFBZ0IsR0FBR3BCLCtDQUFRQSxDQUFnQjtJQUNoRSxNQUFNLENBQUNxQixnQkFBZ0JDLGtCQUFrQixHQUFHdEIsK0NBQVFBLENBQWdCO0lBQ3BFLE1BQU0sQ0FBQ3VCLFlBQVlDLGNBQWMsR0FBR3hCLCtDQUFRQSxDQUFDO1FBQUV5QixPQUFPO1FBQUtDLFFBQVE7SUFBSTtJQUN2RSxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBRzVCLCtDQUFRQSxDQUFDO1FBQUU2QixHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUV0RCxNQUFNQyxVQUFVO1FBQUVDLEtBQUs7UUFBSUMsT0FBTztRQUFJQyxRQUFRO1FBQUlDLE1BQU07SUFBRztJQUUzRHJDLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTXNDLG1CQUFtQjtZQUN2QixJQUFJbEIsYUFBYW1CLE9BQU8sRUFBRTtnQkFDeEIsTUFBTSxFQUFFWixLQUFLLEVBQUUsR0FBR1AsYUFBYW1CLE9BQU8sQ0FBQ0MscUJBQXFCO2dCQUM1RGQsY0FBYztvQkFBRUM7b0JBQU9DLFFBQVFhLEtBQUtDLEdBQUcsQ0FBQyxLQUFLZixRQUFRO2dCQUFNO1lBQzdEO1FBQ0Y7UUFFQVc7UUFDQUssT0FBT0MsZ0JBQWdCLENB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Ozs7OztnQ0FHYk8sTUFBTVcsS0FBSyxrQkFDViw4REFBQ0o7b0NBQ0NDLEdBQUc7b0NBQ0g1QyxNQUFLO29DQUNMMUIsUUFBTztvQ0FDUHVFLGFBQWE7b0NBQ2JDLFNBQVM7b0NBQ1RqQixXQUFVOzs7Ozs7OENBR2QsOERBQUNtQjtvQ0FBY3hILEdBQUcsQ0FBQztvQ0FBSUMsR0FBRyxDQUFDO29DQUFJTCxPQUFPO29DQUFJQyxRQUFROzhDQUNoRCw0RUFBQ3FHO3dDQUNDRyxXQUFXLDBCQUF1RCxPQUE3QlEsWUFBWSxjQUFjO3dDQUMvRHpFLE9BQU87NENBQ0w4QixPQUFPbEIsVUFBVUEsUUFBUWtCLEtBQUssR0FBRzs0Q0FDakNiLFFBQVF3RCxZQUFZLHNDQUFzQzt3Q0FDNUQ7Ozs7Ozs7Ozs7OzsyQkEzQkVELE1BQU1hLEVBQUU7Ozs7O29CQWdDcEI7b0JBR0N0SSxXQUFXVyxTQUFTRSxDQUFDLEdBQUdFLFFBQVFJLElBQUksSUFBSVIsU0FBU0UsQ0FBQyxHQUFHTixXQUFXRSxLQUFLLEdBQUdNLFFBQVFFLEtBQUssSUFDcEZOLFNBQVNHLENBQUMsR0FBR0MsUUFBUUMsR0FBRyxJQUFJTCxTQUFTRyxDQUFDLEdBQUdQLFdBQVdHLE1BQU0sR0FBR0ssUUFBUUcsTUFBTSxrQkFDM0UsOERBQUM0Rzt3QkFBRUMsV0FBVyxhQUE0QnBILE9BQWZBLFNBQVNFLENBQUMsRUFBQyxNQUFlLE9BQVhGLFNBQVNHLENBQUMsRUFBQzt3QkFBSXFILFNBQVM7a0NBQ2hFLDRFQUFDRTs0QkFBY3hILEdBQUcsQ0FBQzs0QkFBSUMsR0FBRyxDQUFDOzRCQUFJTCxPQUFPOzRCQUFJQyxRQUFRO3NDQUNoRCw0RUFBQ3FHO2dDQUFjRyxXQUFVO2dDQUFVakUsT0FBTztvQ0FBRThCLE9BQU87Z0NBQXNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT3ZGO0dBalhnQjNGO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL1NjYXR0ZXJQbG90LnRzeD8xOWE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERhdGFQb2ludCwgQ2x1c3RlckluZm8gfSBmcm9tICdAc2hhcmVkL3NjaGVtYSc7XG5pbXBvcnQgeyBVc2VyLCBNYXBQaW4sIFNob3BwaW5nQmFnIH0gZnJvbSAnbHVjaWRlLXJlYWN0JztcblxuaW50ZXJmYWNlIFNjYXR0ZXJQbG90UHJvcHMge1xuICBkYXRhUG9pbnRzOiBEYXRhUG9pbnRbXTtcbiAgY2x1c3RlcnM6IENsdXN0ZXJJbmZvW107XG4gIGNvbm5lY3Rpb25zOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPjtcbiAgZGF0YXNldFR5cGU6ICdtZWRpY2FsJyB8ICdjcmltZScgfCAnY3VzdG9tZXInO1xuICB4TGFiZWw6IHN0cmluZztcbiAgeUxhYmVsOiBzdHJpbmc7XG4gIHhSYW5nZT86IFtudW1iZXIsIG51bWJlcl07XG4gIHlSYW5nZT86IFtudW1iZXIsIG51bWJlcl07XG4gIG9uQWRkUG9pbnQ/OiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHZvaWQ7XG4gIG9uUG9pbnRIb3Zlcj86IChwb2ludDogRGF0YVBvaW50IHwgbnVsbCkgPT4gdm9pZDtcbiAgb25DbHVzdGVySG92ZXI/OiAoY2x1c3RlcjogQ2x1c3RlckluZm8gfCBudWxsKSA9PiB2b2lkO1xuICBhZGRNb2RlOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2NhdHRlclBsb3Qoe1xuICBkYXRhUG9pbnRzLFxuICBjbHVzdGVycyxcbiAgY29ubmVjdGlvbnMsXG4gIGRhdGFzZXRUeXBlLFxuICB4TGFiZWwsXG4gIHlMYWJlbCxcbiAgeFJhbmdlLFxuICB5UmFuZ2UsXG4gIG9uQWRkUG9pbnQsXG4gIG9uUG9pbnRIb3ZlcixcbiAgb25DbHVzdGVySG92ZXIsXG4gIGFkZE1vZGUsXG59OiBTY2F0dGVyUGxvdFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFtob3ZlcmVkUG9pbnQsIHNldEhvdmVyZWRQb2ludF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2hvdmVyZWRDbHVzdGVyLCBzZXRIb3ZlcmVkQ2x1c3Rlcl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2RpbWVuc2lvbnMsIHNldERpbWVuc2lvbnNdID0gdXNlU3RhdGUoeyB3aWR0aDogODAwLCBoZWlnaHQ6IDYwMCB9KTtcbiAgY29uc3QgW21vdXNlUG9zLCBzZXRNb3VzZVBvc10gPSB1c2VTdGF0ZSh7IHg6IDAsIHk6IDAgfSk7XG5cbiAgY29uc3QgcGFkZGluZyA9IHsgdG9wOiA0MCwgcmlnaHQ6IDQwLCBib3R0b206IDYwLCBsZWZ0OiA3MCB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgc2V0RGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQ6IE1hdGgubWF4KDUwMCwgd2lkdGggKiAwLjc1KSB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZ2V0U2NhbGVzID0gKCkgPT4ge1xuICAgIGlmICh4UmFuZ2UgJiYgeVJhbmdlKSB7XG4gICAgICAvLyBVc2UgcHJvdmlkZWQgcmFuZ2VzXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4TWluOiB4UmFuZ2VbMF0sXG4gICAgICAgIHhNYXg6IHhSYW5nZVsxXSxcbiAgICAgICAgeU1pbjogeVJhbmdlWzBdLFxuICAgICAgICB5TWF4OiB5UmFuZ2VbMV0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIGRhdGEtYmFzZWQgc2NhbGluZ1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBkYXRhUG9pbnRzLm1hcChwID0+IHAueCk7XG4gICAgY29uc3QgeVZhbHVlcyA9IGRhdGFQb2ludHMubWFwKHAgPT4gcC55KTtcblxuICAgIGNvbnN0IHhNaW4gPSBNYXRoLm1pbiguLi54VmFsdWVzKTtcbiAgICBjb25zdCB4TWF4ID0gTWF0aC5tYXgoLi4ueFZhbHVlcyk7XG4gICAgY29uc3QgeU1pbiA9IE1hdGgubWluKC4uLnlWYWx1ZXMpO1xuICAgIGNvbnN0IHlNYXggPSBNYXRoLm1heCguLi55VmFsdWVzKTtcblxuICAgIGNvbnN0IHhSYW5nZSA9IHhNYXggLSB4TWluIHx8IDE7XG4gICAgY29uc3QgeVJhbmdlID0geU1heCAtIHlNaW4gfHwgMTtcblxuICAgIHJldHVybiB7XG4gICAgICB4TWluOiB4TWluIC0geFJhbmdlICogMC4xLFxuICAgICAgeE1heDogeE1heCArIHhSYW5nZSAqIDAuMSxcbiAgICAgIHlNaW46IHlNaW4gLSB5UmFuZ2UgKiAwLjEsXG4gICAgICB5TWF4OiB5TWF4ICsgeVJhbmdlICogMC4xLFxuICAgIH07XG4gIH07XG5cbiAgY29uc3Qgc2NhbGVYID0gKHg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHNjYWxlcyA9IGdldFNjYWxlcygpO1xuICAgIHJldHVybiBwYWRkaW5nLmxlZnQgKyAoKHggLSBzY2FsZXMueE1pbikgLyAoc2NhbGVzLnhNYXggLSBzY2FsZXMueE1pbikpICogKGRpbWVuc2lvbnMud2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0KTtcbiAgfTtcblxuICBjb25zdCBzY2FsZVkgPSAoeTogbnVtYmVyKSA9PiB7XG4gICAgY29uc3Qgc2NhbGVzID0gZ2V0U2NhbGVzKCk7XG4gICAgcmV0dXJuIGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20gLSAoKHkgLSBzY2FsZXMueU1pbikgLyAoc2NhbGVzLnlNYXggLSBzY2FsZXMueU1pbikpICogKGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSk7XG4gIH07XG5cbiAgY29uc3QgaW52ZXJzZVNjYWxlWCA9IChweDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3Qgc2NhbGVzID0gZ2V0U2NhbGVzKCk7XG4gICAgcmV0dXJuIHNjYWxlcy54TWluICsgKChweCAtIHBhZGRpbmcubGVmdCkgLyAoZGltZW5zaW9ucy53aWR0aCAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQpKSAqIChzY2FsZXMueE1heCAtIHNjYWxlcy54TWluKTtcbiAgfTtcblxuICBjb25zdCBpbnZlcnNlU2NhbGVZID0gKHB4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBzY2FsZXMgPSBnZXRTY2FsZXMoKTtcbiAgICByZXR1cm4gc2NhbGVzLnlNaW4gKyAoKGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20gLSBweCkgLyAoZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tKSkgKiAoc2NhbGVzLnlNYXggLSBzY2FsZXMueU1pbik7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCAqIGRwcjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKiBkcHI7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7ZGltZW5zaW9ucy53aWR0aH1weGA7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2RpbWVuc2lvbnMuaGVpZ2h0fXB4YDtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG5cbiAgICAvLyBEcmF3IGdyaWRcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnaHNsKHZhcigtLWJvcmRlcikpJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDEwOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAoaSAvIDEwKSAqIChkaW1lbnNpb25zLndpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodCk7XG4gICAgICBjb25zdCB5ID0gcGFkZGluZy50b3AgKyAoaSAvIDEwKSAqIChkaW1lbnNpb25zLmhlaWdodCAtIHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20pO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgsIHBhZGRpbmcudG9wKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLmJvdHRvbSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocGFkZGluZy5sZWZ0LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oZGltZW5zaW9ucy53aWR0aCAtIHBhZGRpbmcucmlnaHQsIHkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAvLyBEcmF3IGNsdXN0ZXJzXG4gICAgY2x1c3RlcnMuZm9yRWFjaCgoY2x1c3RlciwgaWR4KSA9PiB7XG4gICAgICBpZiAoY2x1c3Rlci5wb2ludEluZGljZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHBvaW50cyA9IGNsdXN0ZXIucG9pbnRJbmRpY2VzLm1hcChpID0+IGRhdGFQb2ludHNbaV0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHhzID0gcG9pbnRzLm1hcChwID0+IHNjYWxlWChwLngpKTtcbiAgICAgIGNvbnN0IHlzID0gcG9pbnRzLm1hcChwID0+IHNjYWxlWShwLnkpKTtcblxuICAgICAgY29uc3QgY2VudGVyWCA9IHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8geHMubGVuZ3RoO1xuICAgICAgY29uc3QgY2VudGVyWSA9IHlzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8geXMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBtYXhEaXN0ID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnhzLm1hcCgoeCwgaSkgPT4gTWF0aC5zcXJ0KCh4IC0gY2VudGVyWCkgKiogMiArICh5c1tpXSAtIGNlbnRlclkpICoqIDIpKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmFkaXVzID0gbWF4RGlzdCArIDMwO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gY2x1c3Rlci5jb2xvci5yZXBsYWNlKCdoc2wnLCAnaHNsYScpLnJlcGxhY2UoJyknLCAnLCAwLjA4KScpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY2x1c3Rlci5jb2xvcjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuXG4gICAgICBpZiAoaG92ZXJlZENsdXN0ZXIgPT09IGlkeCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY2x1c3Rlci5jb2xvci5yZXBsYWNlKCdoc2wnLCAnaHNsYScpLnJlcGxhY2UoJyknLCAnLCAwLjE1KScpO1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBjbHVzdGVyLmNvbG9yO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDE1O1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgIH0pO1xuXG4gICAgLy8gRHJhdyBjb25uZWN0aW9uc1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdoc2wodmFyKC0tcHJpbWFyeSkpJztcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjY7XG4gICAgY3R4LnNldExpbmVEYXNoKFs0LCA0XSk7XG5cbiAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChbaSwgal0pID0+IHtcbiAgICAgIGNvbnN0IHAxID0gZGF0YVBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHAyID0gZGF0YVBvaW50c1tqXTtcbiAgICAgIGlmICghcDEgfHwgIXAyKSByZXR1cm47XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oc2NhbGVYKHAxLngpLCBzY2FsZVkocDEueSkpO1xuICAgICAgY3R4LmxpbmVUbyhzY2FsZVgocDIueCksIHNjYWxlWShwMi55KSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSk7XG5cbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAvLyBEcmF3IGF4ZXNcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnaHNsKHZhcigtLWZvcmVncm91bmQpKSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDI7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhwYWRkaW5nLmxlZnQsIHBhZGRpbmcudG9wKTtcbiAgICBjdHgubGluZVRvKHBhZGRpbmcubGVmdCwgZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLmJvdHRvbSk7XG4gICAgY3R4LmxpbmVUbyhkaW1lbnNpb25zLndpZHRoIC0gcGFkZGluZy5yaWdodCwgZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLmJvdHRvbSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gRHJhdyBheGlzIGxhYmVsc1xuICAgIGN0eC5maWxsU3R5bGUgPSAnaHNsKHZhcigtLWZvcmVncm91bmQpKSc7XG4gICAgY3R4LmZvbnQgPSAnMTRweCBJbnRlcic7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC5maWxsVGV4dCh4TGFiZWwsIGRpbWVuc2lvbnMud2lkdGggLyAyLCBkaW1lbnNpb25zLmhlaWdodCAtIDIwKTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSgyMCwgZGltZW5zaW9ucy5oZWlnaHQgLyAyKTtcbiAgICBjdHgucm90YXRlKC1NYXRoLlBJIC8gMik7XG4gICAgY3R4LmZpbGxUZXh0KHlMYWJlbCwgMCwgMCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICB9LCBbZGF0YVBvaW50cywgY2x1c3RlcnMsIGNvbm5lY3Rpb25zLCBkaW1lbnNpb25zLCB4TGFiZWwsIHlMYWJlbCwgaG92ZXJlZENsdXN0ZXJdKTtcblxuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCByZWN0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghcmVjdCkgcmV0dXJuO1xuXG4gICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG5cbiAgICBzZXRNb3VzZVBvcyh7IHgsIHkgfSk7XG5cbiAgICAvLyBDaGVjayBmb3IgaG92ZXJlZCBwb2ludHNcbiAgICBsZXQgZm91bmRQb2ludCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHggPSBzY2FsZVgoZGF0YVBvaW50c1tpXS54KTtcbiAgICAgIGNvbnN0IHB5ID0gc2NhbGVZKGRhdGFQb2ludHNbaV0ueSk7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KChweCAtIHgpICoqIDIgKyAocHkgLSB5KSAqKiAyKTtcblxuICAgICAgaWYgKGRpc3QgPCAxNSkge1xuICAgICAgICBzZXRIb3ZlcmVkUG9pbnQoaSk7XG4gICAgICAgIG9uUG9pbnRIb3Zlcj8uKGRhdGFQb2ludHNbaV0pO1xuICAgICAgICBmb3VuZFBvaW50ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3VuZFBvaW50KSB7XG4gICAgICBzZXRIb3ZlcmVkUG9pbnQobnVsbCk7XG4gICAgICBvblBvaW50SG92ZXI/LihudWxsKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgaG92ZXJlZCBjbHVzdGVyc1xuICAgIGxldCBmb3VuZENsdXN0ZXIgPSBmYWxzZTtcbiAgICBjbHVzdGVycy5mb3JFYWNoKChjbHVzdGVyLCBpZHgpID0+IHtcbiAgICAgIGlmIChjbHVzdGVyLnBvaW50SW5kaWNlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgY29uc3QgcG9pbnRzID0gY2x1c3Rlci5wb2ludEluZGljZXMubWFwKGkgPT4gZGF0YVBvaW50c1tpXSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgY29uc3QgeHMgPSBwb2ludHMubWFwKHAgPT4gc2NhbGVYKHAueCkpO1xuICAgICAgY29uc3QgeXMgPSBwb2ludHMubWFwKHAgPT4gc2NhbGVZKHAueSkpO1xuXG4gICAgICBjb25zdCBjZW50ZXJYID0geHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyB4cy5sZW5ndGg7XG4gICAgICBjb25zdCBjZW50ZXJZID0geXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyB5cy5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IG1heERpc3QgPSBNYXRoLm1heChcbiAgICAgICAgLi4ueHMubWFwKCh4LCBpKSA9PiBNYXRoLnNxcnQoKHggLSBjZW50ZXJYKSAqKiAyICsgKHlzW2ldIC0gY2VudGVyWSkgKiogMikpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByYWRpdXMgPSBtYXhEaXN0ICsgMzA7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KChjZW50ZXJYIC0geCkgKiogMiArIChjZW50ZXJZIC0geSkgKiogMik7XG5cbiAgICAgIGlmIChkaXN0IDwgcmFkaXVzICYmICFmb3VuZFBvaW50KSB7XG4gICAgICAgIHNldEhvdmVyZWRDbHVzdGVyKGlkeCk7XG4gICAgICAgIG9uQ2x1c3RlckhvdmVyPy4oY2x1c3Rlcik7XG4gICAgICAgIGZvdW5kQ2x1c3RlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWZvdW5kQ2x1c3Rlcikge1xuICAgICAgc2V0SG92ZXJlZENsdXN0ZXIobnVsbCk7XG4gICAgICBpZiAoIWZvdW5kUG9pbnQpIG9uQ2x1c3RlckhvdmVyPy4obnVsbCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKCFhZGRNb2RlIHx8ICFvbkFkZFBvaW50KSByZXR1cm47XG5cbiAgICBjb25zdCByZWN0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghcmVjdCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2xpY2tYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIGNvbnN0IGNsaWNrWSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgLy8gQ2hlY2sgaWYgY2xpY2tlZCB3aXRoaW4gcGxvdCBhcmVhXG4gICAgaWYgKFxuICAgICAgY2xpY2tYID49IHBhZGRpbmcubGVmdCAmJlxuICAgICAgY2xpY2tYIDw9IGRpbWVuc2lvbnMud2lkdGggLSBwYWRkaW5nLnJpZ2h0ICYmXG4gICAgICBjbGlja1kgPj0gcGFkZGluZy50b3AgJiZcbiAgICAgIGNsaWNrWSA8PSBkaW1lbnNpb25zLmhlaWdodCAtIHBhZGRpbmcuYm90dG9tXG4gICAgKSB7XG4gICAgICBjb25zdCBkYXRhWCA9IGludmVyc2VTY2FsZVgoY2xpY2tYKTtcbiAgICAgIGNvbnN0IGRhdGFZID0gaW52ZXJzZVNjYWxlWShjbGlja1kpO1xuICAgICAgb25BZGRQb2ludChkYXRhWCwgZGF0YVkpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBJY29uQ29tcG9uZW50ID0gZGF0YXNldFR5cGUgPT09ICdtZWRpY2FsJyA/IFVzZXIgOiBkYXRhc2V0VHlwZSA9PT0gJ2NyaW1lJyA/IE1hcFBpbiA6IFNob3BwaW5nQmFnO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgYmctY2FyZCByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItY2FyZC1ib3JkZXIgb3ZlcmZsb3ctdmlzaWJsZVwiXG4gICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiB7XG4gICAgICAgIHNldEhvdmVyZWRQb2ludChudWxsKTtcbiAgICAgICAgc2V0SG92ZXJlZENsdXN0ZXIobnVsbCk7XG4gICAgICAgIG9uUG9pbnRIb3Zlcj8uKG51bGwpO1xuICAgICAgICBvbkNsdXN0ZXJIb3Zlcj8uKG51bGwpO1xuICAgICAgfX1cbiAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgc3R5bGU9e3sgY3Vyc29yOiBhZGRNb2RlID8gJ2Nyb3NzaGFpcicgOiAnZGVmYXVsdCcgfX1cbiAgICA+XG4gICAgICA8Y2FudmFzIHJlZj17Y2FudmFzUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGxcIiAvPlxuXG4gICAgICB7LyogU1ZHIG92ZXJsYXkgZm9yIGljb25zICovfVxuICAgICAgPHN2Z1xuICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgIHdpZHRoPXtkaW1lbnNpb25zLndpZHRofVxuICAgICAgICBoZWlnaHQ9e2RpbWVuc2lvbnMuaGVpZ2h0fVxuICAgICAgICBzdHlsZT17eyBvdmVyZmxvdzogJ3Zpc2libGUnIH19XG4gICAgICA+XG4gICAgICAgIHtkYXRhUG9pbnRzLm1hcCgocG9pbnQsIGlkeCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHggPSBzY2FsZVgocG9pbnQueCk7XG4gICAgICAgICAgY29uc3QgeSA9IHNjYWxlWShwb2ludC55KTtcbiAgICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSBob3ZlcmVkUG9pbnQgPT09IGlkeDtcbiAgICAgICAgICBjb25zdCBjbHVzdGVyID0gY2x1c3RlcnMuZmluZChjID0+IGMucG9pbnRJbmRpY2VzLmluY2x1ZGVzKGlkeCkpO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxnIGtleT17cG9pbnQuaWR9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3h9LCAke3l9KWB9PlxuICAgICAgICAgICAgICB7aXNIb3ZlcmVkICYmIChcbiAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICByPXsxOH1cbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImhzbCh2YXIoLS1wcmltYXJ5KSlcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgICAgICAgICBvcGFjaXR5PXswLjV9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhbmltYXRlLXB1bHNlXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICB7cG9pbnQuaXNOZXcgJiYgKFxuICAgICAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgICAgIHI9ezIwfVxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiaHNsKHZhcigtLWNoYXJ0LTUpKVwiXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17M31cbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk9ezAuN31cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFuaW1hdGUtcHVsc2VcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDxmb3JlaWduT2JqZWN0IHg9ey0xMn0geT17LTEyfSB3aWR0aD17MjR9IGhlaWdodD17MjR9PlxuICAgICAgICAgICAgICAgIDxJY29uQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B3LTYgaC02IHRyYW5zaXRpb24tYWxsICR7aXNIb3ZlcmVkID8gJ3NjYWxlLTEyNScgOiAnJ31gfVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNsdXN0ZXIgPyBjbHVzdGVyLmNvbG9yIDogJ2hzbCh2YXIoLS1mb3JlZ3JvdW5kKSknLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGlzSG92ZXJlZCA/ICdkcm9wLXNoYWRvdygwIDAgNHB4IGN1cnJlbnRDb2xvciknIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2ZvcmVpZ25PYmplY3Q+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG5cbiAgICAgICAgey8qIEdob3N0IGljb24gZm9yIGFkZCBtb2RlICovfVxuICAgICAgICB7YWRkTW9kZSAmJiBtb3VzZVBvcy54ID4gcGFkZGluZy5sZWZ0ICYmIG1vdXNlUG9zLnggPCBkaW1lbnNpb25zLndpZHRoIC0gcGFkZGluZy5yaWdodCAmJlxuICAgICAgICAgIG1vdXNlUG9zLnkgPiBwYWRkaW5nLnRvcCAmJiBtb3VzZVBvcy55IDwgZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLmJvdHRvbSAmJiAoXG4gICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7bW91c2VQb3MueH0sICR7bW91c2VQb3MueX0pYH0gb3BhY2l0eT17MC41fT5cbiAgICAgICAgICAgIDxmb3JlaWduT2JqZWN0IHg9ey0xMn0geT17LTEyfSB3aWR0aD17MjR9IGhlaWdodD17MjR9PlxuICAgICAgICAgICAgICA8SWNvbkNvbXBvbmVudCBjbGFzc05hbWU9XCJ3LTYgaC02XCIgc3R5bGU9e3sgY29sb3I6ICdoc2wodmFyKC0tcHJpbWFyeSkpJyB9fSAvPlxuICAgICAgICAgICAgPC9mb3JlaWduT2JqZWN0PlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKX1cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiVXNlciIsIk1hcFBpbiIsIlNob3BwaW5nQmFnIiwiU2NhdHRlclBsb3QiLCJkYXRhUG9pbnRzIiwiY2x1c3RlcnMiLCJjb25uZWN0aW9ucyIsImRhdGFzZXRUeXBlIiwieExhYmVsIiwieUxhYmVsIiwieFJhbmdlIiwieVJhbmdlIiwib25BZGRQb2ludCIsIm9uUG9pbnRIb3ZlciIsIm9uQ2x1c3RlckhvdmVyIiwiYWRkTW9kZSIsImNhbnZhc1JlZiIsImNvbnRhaW5lclJlZiIsImhvdmVyZWRQb2ludCIsInNldEhvdmVyZWRQb2ludCIsImhvdmVyZWRDbHVzdGVyIiwic2V0SG92ZXJlZENsdXN0ZXIiLCJkaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwibW91c2VQb3MiLCJzZXRNb3VzZVBvcyIsIngiLCJ5IiwicGFkZGluZyIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInVwZGF0ZURpbWVuc2lvbnMiLCJjdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiTWF0aCIsIm1heCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0U2NhbGVzIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsInhWYWx1ZXMiLCJtYXAiLCJwIiwieVZhbHVlcyIsIm1pbiIsInNjYWxlWCIsInNjYWxlcyIsInNjYWxlWSIsImludmVyc2VTY2FsZVgiLCJweCIsImludmVyc2VTY2FsZVkiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInN0eWxlIiwic2NhbGUiLCJjbGVhclJlY3QiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImdsb2JhbEFscGhhIiwiaSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImZvckVhY2giLCJjbHVzdGVyIiwiaWR4IiwicG9pbnRJbmRpY2VzIiwibGVuZ3RoIiwicG9pbnRzIiwiZmlsdGVyIiwiQm9vbGVhbiIsInhzIiwieXMiLCJjZW50ZXJYIiwicmVkdWNlIiwiYSIsImIiLCJjZW50ZXJZIiwibWF4RGlzdCIsInNxcnQiLCJyYWRpdXMiLCJmaWxsU3R5bGUiLCJjb2xvciIsInJlcGxhY2UiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJhcmMiLCJQSSIsImZpbGwiLCJzZXRMaW5lRGFzaCIsImoiLCJwMSIsInAyIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxUZXh0Iiwic2F2ZSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlc3RvcmUiLCJoYW5kbGVNb3VzZU1vdmUiLCJlIiwicmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwiZm91bmRQb2ludCIsInB5IiwiZGlzdCIsImZvdW5kQ2x1c3RlciIsImhhbmRsZUNsaWNrIiwiY2xpY2tYIiwiY2xpY2tZIiwiZGF0YVgiLCJkYXRhWSIsIkljb25Db21wb25lbnQiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VMZWF2ZSIsIm9uQ2xpY2siLCJjdXJzb3IiLCJzdmciLCJvdmVyZmxvdyIsInBvaW50IiwiaXNIb3ZlcmVkIiwiZmluZCIsImMiLCJpbmNsdWRlcyIsImciLCJ0cmFuc2Zvcm0iLCJjaXJjbGUiLCJyIiwic3Ryb2tlV2lkdGgiLCJvcGFjaXR5IiwiaXNOZXciLCJmb3JlaWduT2JqZWN0IiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/ScatterPlot.tsx\n"));

/***/ })

});