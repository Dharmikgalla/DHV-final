"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_App_tsx",{

/***/ "(app-pages-browser)/./app/components/ScatterPlot.tsx":
/*!****************************************!*\
  !*** ./app/components/ScatterPlot.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScatterPlot: function() { return /* binding */ ScatterPlot; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=MapPin,ShoppingBag,User!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/user.js\");\n/* harmony import */ var _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=MapPin,ShoppingBag,User!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/map-pin.js\");\n/* harmony import */ var _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=MapPin,ShoppingBag,User!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/shopping-bag.js\");\n\nvar _s = $RefreshSig$();\n\n\nfunction ScatterPlot(param) {\n    let { dataPoints, clusters, connections, datasetType, xLabel, yLabel, onAddPoint, onPointHover, onClusterHover, addMode } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [hoveredPoint, setHoveredPoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoveredCluster, setHoveredCluster] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 800,\n        height: 600\n    });\n    const [mousePos, setMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const padding = {\n        top: 40,\n        right: 40,\n        bottom: 60,\n        left: 70\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (containerRef.current) {\n                const { width } = containerRef.current.getBoundingClientRect();\n                setDimensions({\n                    width,\n                    height: Math.max(500, width * 0.75)\n                });\n            }\n        };\n        updateDimensions();\n        window.addEventListener(\"resize\", updateDimensions);\n        return ()=>window.removeEventListener(\"resize\", updateDimensions);\n    }, []);\n    const getScales = ()=>{\n        const xValues = dataPoints.map((p)=>p.x);\n        const yValues = dataPoints.map((p)=>p.y);\n        const xMin = Math.min(...xValues);\n        const xMax = Math.max(...xValues);\n        const yMin = Math.min(...yValues);\n        const yMax = Math.max(...yValues);\n        const xRange = xMax - xMin || 1;\n        const yRange = yMax - yMin || 1;\n        return {\n            xMin: xMin - xRange * 0.1,\n            xMax: xMax + xRange * 0.1,\n            yMin: yMin - yRange * 0.1,\n            yMax: yMax + yRange * 0.1\n        };\n    };\n    const scaleX = (x)=>{\n        const scales = getScales();\n        return padding.left + (x - scales.xMin) / (scales.xMax - scales.xMin) * (dimensions.width - padding.left - padding.right);\n    };\n    const scaleY = (y)=>{\n        const scales = getScales();\n        return dimensions.height - padding.bottom - (y - scales.yMin) / (scales.yMax - scales.yMin) * (dimensions.height - padding.top - padding.bottom);\n    };\n    const inverseScaleX = (px)=>{\n        const scales = getScales();\n        return scales.xMin + (px - padding.left) / (dimensions.width - padding.left - padding.right) * (scales.xMax - scales.xMin);\n    };\n    const inverseScaleY = (px)=>{\n        const scales = getScales();\n        return scales.yMin + (dimensions.height - padding.bottom - px) / (dimensions.height - padding.top - padding.bottom) * (scales.yMax - scales.yMin);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const dpr = window.devicePixelRatio || 1;\n        canvas.width = dimensions.width * dpr;\n        canvas.height = dimensions.height * dpr;\n        canvas.style.width = \"\".concat(dimensions.width, \"px\");\n        canvas.style.height = \"\".concat(dimensions.height, \"px\");\n        ctx.scale(dpr, dpr);\n        ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n        // Draw grid\n        ctx.strokeStyle = \"hsl(var(--border))\";\n        ctx.lineWidth = 0.5;\n        ctx.globalAlpha = 0.3;\n        for(let i = 0; i <= 10; i++){\n            const x = padding.left + i / 10 * (dimensions.width - padding.left - padding.right);\n            const y = padding.top + i / 10 * (dimensions.height - padding.top - padding.bottom);\n            ctx.beginPath();\n            ctx.moveTo(x, padding.top);\n            ctx.lineTo(x, dimensions.height - padding.bottom);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.moveTo(padding.left, y);\n            ctx.lineTo(dimensions.width - padding.right, y);\n            ctx.stroke();\n        }\n        ctx.globalAlpha = 1;\n        // Draw clusters\n        clusters.forEach((cluster, idx)=>{\n            if (cluster.pointIndices.length === 0) return;\n            const points = cluster.pointIndices.map((i)=>dataPoints[i]).filter(Boolean);\n            if (points.length === 0) return;\n            const xs = points.map((p)=>scaleX(p.x));\n            const ys = points.map((p)=>scaleY(p.y));\n            const centerX = xs.reduce((a, b)=>a + b, 0) / xs.length;\n            const centerY = ys.reduce((a, b)=>a + b, 0) / ys.length;\n            const maxDist = Math.max(...xs.map((x, i)=>Math.sqrt((x - centerX) ** 2 + (ys[i] - centerY) ** 2)));\n            const radius = maxDist + 30;\n            ctx.fillStyle = cluster.color.replace(\"hsl\", \"hsla\").replace(\")\", \", 0.08)\");\n            ctx.strokeStyle = cluster.color;\n            ctx.lineWidth = 3;\n            if (hoveredCluster === idx) {\n                ctx.fillStyle = cluster.color.replace(\"hsl\", \"hsla\").replace(\")\", \", 0.15)\");\n                ctx.shadowColor = cluster.color;\n                ctx.shadowBlur = 15;\n            }\n            ctx.beginPath();\n            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.stroke();\n            ctx.shadowBlur = 0;\n        });\n        // Draw connections\n        ctx.strokeStyle = \"hsl(var(--primary))\";\n        ctx.lineWidth = 2;\n        ctx.globalAlpha = 0.6;\n        ctx.setLineDash([\n            4,\n            4\n        ]);\n        connections.forEach((param)=>{\n            let [i, j] = param;\n            const p1 = dataPoints[i];\n            const p2 = dataPoints[j];\n            if (!p1 || !p2) return;\n            ctx.beginPath();\n            ctx.moveTo(scaleX(p1.x), scaleY(p1.y));\n            ctx.lineTo(scaleX(p2.x), scaleY(p2.y));\n            ctx.stroke();\n        });\n        ctx.setLineDash([]);\n        ctx.globalAlpha = 1;\n        // Draw axes\n        ctx.strokeStyle = \"hsl(var(--foreground))\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(padding.left, padding.top);\n        ctx.lineTo(padding.left, dimensions.height - padding.bottom);\n        ctx.lineTo(dimensions.width - padding.right, dimensions.height - padding.bottom);\n        ctx.stroke();\n        // Draw axis labels\n        ctx.fillStyle = \"hsl(var(--foreground))\";\n        ctx.font = \"14px Inter\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(xLabel, dimensions.width / 2, dimensions.height - 20);\n        ctx.save();\n        ctx.translate(20, dimensions.height / 2);\n        ctx.rotate(-Math.PI / 2);\n        ctx.fillText(yLabel, 0, 0);\n        ctx.restore();\n    }, [\n        dataPoints,\n        clusters,\n        connections,\n        dimensions,\n        xLabel,\n        yLabel,\n        hoveredCluster\n    ]);\n    const handleMouseMove = (e)=>{\n        var _containerRef_current;\n        const rect = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect();\n        if (!rect) return;\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        setMousePos({\n            x,\n            y\n        });\n        // Check for hovered points\n        let foundPoint = false;\n        for(let i = 0; i < dataPoints.length; i++){\n            const px = scaleX(dataPoints[i].x);\n            const py = scaleY(dataPoints[i].y);\n            const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);\n            if (dist < 15) {\n                setHoveredPoint(i);\n                onPointHover === null || onPointHover === void 0 ? void 0 : onPointHover(dataPoints[i]);\n                foundPoint = true;\n                break;\n            }\n        }\n        if (!foundPoint) {\n            setHoveredPoint(null);\n            onPointHover === null || onPointHover === void 0 ? void 0 : onPointHover(null);\n        }\n        // Check for hovered clusters\n        let foundCluster = false;\n        clusters.forEach((cluster, idx)=>{\n            if (cluster.pointIndices.length === 0) return;\n            const points = cluster.pointIndices.map((i)=>dataPoints[i]).filter(Boolean);\n            if (points.length === 0) return;\n            const xs = points.map((p)=>scaleX(p.x));\n            const ys = points.map((p)=>scaleY(p.y));\n            const centerX = xs.reduce((a, b)=>a + b, 0) / xs.length;\n            const centerY = ys.reduce((a, b)=>a + b, 0) / ys.length;\n            const maxDist = Math.max(...xs.map((x, i)=>Math.sqrt((x - centerX) ** 2 + (ys[i] - centerY) ** 2)));\n            const radius = maxDist + 30;\n            const dist = Math.sqrt((centerX - x) ** 2 + (centerY - y) ** 2);\n            if (dist < radius && !foundPoint) {\n                setHoveredCluster(idx);\n                onClusterHover === null || onClusterHover === void 0 ? void 0 : onClusterHover(cluster);\n                foundCluster = true;\n            }\n        });\n        if (!foundCluster) {\n            setHoveredCluster(null);\n            if (!foundPoint) onClusterHover === null || onClusterHover === void 0 ? void 0 : onClusterHover(null);\n        }\n    };\n    const handleClick = (e)=>{\n        var _containerRef_current;\n        if (!addMode || !onAddPoint) return;\n        const rect = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect();\n        if (!rect) return;\n        const clickX = e.clientX - rect.left;\n        const clickY = e.clientY - rect.top;\n        // Check if clicked within plot area\n        if (clickX >= padding.left && clickX <= dimensions.width - padding.right && clickY >= padding.top && clickY <= dimensions.height - padding.bottom) {\n            const dataX = inverseScaleX(clickX);\n            const dataY = inverseScaleY(clickY);\n            onAddPoint(dataX, dataY);\n        }\n    };\n    const IconComponent = datasetType === \"medical\" ? _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : datasetType === \"crime\" ? _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"] : _barrel_optimize_names_MapPin_ShoppingBag_User_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"relative w-full bg-card rounded-md border border-card-border overflow-visible\",\n        onMouseMove: handleMouseMove,\n        onMouseLeave: ()=>{\n            setHoveredPoint(null);\n            setHoveredCluster(null);\n            onPointHover === null || onPointHover === void 0 ? void 0 : onPointHover(null);\n            onClusterHover === null || onClusterHover === void 0 ? void 0 : onClusterHover(null);\n        },\n        onClick: handleClick,\n        style: {\n            cursor: addMode ? \"crosshair\" : \"default\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: \"w-full\"\n            }, void 0, false, {\n                fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                lineNumber: 314,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                className: \"absolute top-0 left-0 pointer-events-none\",\n                width: dimensions.width,\n                height: dimensions.height,\n                style: {\n                    overflow: \"visible\"\n                },\n                children: [\n                    dataPoints.map((point, idx)=>{\n                        const x = scaleX(point.x);\n                        const y = scaleY(point.y);\n                        const isHovered = hoveredPoint === idx;\n                        const cluster = clusters.find((c)=>c.pointIndices.includes(idx));\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n                            children: [\n                                isHovered && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    r: 18,\n                                    fill: \"none\",\n                                    stroke: \"hsl(var(--primary))\",\n                                    strokeWidth: 2,\n                                    opacity: 0.5,\n                                    className: \"animate-pulse\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                    lineNumber: 332,\n                                    columnNumber: 17\n                                }, this),\n                                point.isNew && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    r: 20,\n                                    fill: \"none\",\n                                    stroke: \"hsl(var(--chart-5))\",\n                                    strokeWidth: 3,\n                                    opacity: 0.7,\n                                    className: \"animate-pulse\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                    lineNumber: 342,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"foreignObject\", {\n                                    x: -12,\n                                    y: -12,\n                                    width: 24,\n                                    height: 24,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                                        className: \"w-6 h-6 transition-all \".concat(isHovered ? \"scale-125\" : \"\"),\n                                        style: {\n                                            color: cluster ? cluster.color : \"hsl(var(--foreground))\",\n                                            filter: isHovered ? \"drop-shadow(0 0 4px currentColor)\" : \"none\"\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                        lineNumber: 352,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                    lineNumber: 351,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, point.id, true, {\n                            fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                            lineNumber: 330,\n                            columnNumber: 13\n                        }, this);\n                    }),\n                    addMode && mousePos.x > padding.left && mousePos.x < dimensions.width - padding.right && mousePos.y > padding.top && mousePos.y < dimensions.height - padding.bottom && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                        transform: \"translate(\".concat(mousePos.x, \", \").concat(mousePos.y, \")\"),\n                        opacity: 0.5,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"foreignObject\", {\n                            x: -12,\n                            y: -12,\n                            width: 24,\n                            height: 24,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                                className: \"w-6 h-6\",\n                                style: {\n                                    color: \"hsl(var(--primary))\"\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                                lineNumber: 369,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                            lineNumber: 368,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                        lineNumber: 367,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n                lineNumber: 317,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/dharmikgalla/DHV-project-2/app/components/ScatterPlot.tsx\",\n        lineNumber: 301,\n        columnNumber: 5\n    }, this);\n}\n_s(ScatterPlot, \"LpbhOkUcx6hnHiX2KWTRe/uzCPs=\");\n_c = ScatterPlot;\nvar _c;\n$RefreshReg$(_c, \"ScatterPlot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1NjYXR0ZXJQbG90LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb0Q7QUFFSztBQWlCbEQsU0FBU00sWUFBWSxLQVdUO1FBWFMsRUFDMUJDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsTUFBTSxFQUNOQyxNQUFNLEVBQ05DLFVBQVUsRUFDVkMsWUFBWSxFQUNaQyxjQUFjLEVBQ2RDLE9BQU8sRUFDVSxHQVhTOztJQVkxQixNQUFNQyxZQUFZaEIsNkNBQU1BLENBQW9CO0lBQzVDLE1BQU1pQixlQUFlakIsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU0sQ0FBQ2tCLGNBQWNDLGdCQUFnQixHQUFHbEIsK0NBQVFBLENBQWdCO0lBQ2hFLE1BQU0sQ0FBQ21CLGdCQUFnQkMsa0JBQWtCLEdBQUdwQiwrQ0FBUUEsQ0FBZ0I7SUFDcEUsTUFBTSxDQUFDcUIsWUFBWUMsY0FBYyxHQUFHdEIsK0NBQVFBLENBQUM7UUFBRXVCLE9BQU87UUFBS0MsUUFBUTtJQUFJO0lBQ3ZFLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHMUIsK0NBQVFBLENBQUM7UUFBRTJCLEdBQUc7UUFBR0MsR0FBRztJQUFFO0lBRXRELE1BQU1DLFVBQVU7UUFBRUMsS0FBSztRQUFJQyxPQUFPO1FBQUlDLFFBQVE7UUFBSUMsTUFBTTtJQUFHO0lBRTNEbkMsZ0RBQVNBLENBQUM7UUFDUixNQUFNb0MsbUJBQW1CO1lBQ3ZCLElBQUlsQixhQUFhbUIsT0FBTyxFQUFFO2dCQUN4QixNQUFNLEVBQUVaLEtBQUssRUFBRSxHQUFHUCxhQUFhbUIsT0FBTyxDQUFDQyxxQkFBcUI7Z0JBQzVEZCxjQUFjO29CQUFFQztvQkFBT0MsUUFBUWEsS0FBS0MsR0FBRyxDQUFDLEtBQUtmLFFBQVE7Z0JBQU07WUFDN0Q7UUFDRjtRQUVBVztRQUNBSyxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVTjtRQUNsQyxPQUFPLElB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QTdCUSxZQUFZLGNBQWM7d0NBQy9EekUsT0FBTzs0Q0FDTDhCLE9BQU9sQixVQUFVQSxRQUFRa0IsS0FBSyxHQUFHOzRDQUNqQ2IsUUFBUXdELFlBQVksc0NBQXNDO3dDQUM1RDs7Ozs7Ozs7Ozs7OzJCQTNCRUQsTUFBTWEsRUFBRTs7Ozs7b0JBZ0NwQjtvQkFHQ3hJLFdBQVdXLFNBQVNFLENBQUMsR0FBR0UsUUFBUUksSUFBSSxJQUFJUixTQUFTRSxDQUFDLEdBQUdOLFdBQVdFLEtBQUssR0FBR00sUUFBUUUsS0FBSyxJQUNwRk4sU0FBU0csQ0FBQyxHQUFHQyxRQUFRQyxHQUFHLElBQUlMLFNBQVNHLENBQUMsR0FBR1AsV0FBV0csTUFBTSxHQUFHSyxRQUFRRyxNQUFNLGtCQUMzRSw4REFBQzhHO3dCQUFFQyxXQUFXLGFBQTRCdEgsT0FBZkEsU0FBU0UsQ0FBQyxFQUFDLE1BQWUsT0FBWEYsU0FBU0csQ0FBQyxFQUFDO3dCQUFJdUgsU0FBUztrQ0FDaEUsNEVBQUNFOzRCQUFjMUgsR0FBRyxDQUFDOzRCQUFJQyxHQUFHLENBQUM7NEJBQUlMLE9BQU87NEJBQUlDLFFBQVE7c0NBQ2hELDRFQUFDdUc7Z0NBQWNHLFdBQVU7Z0NBQVVqRSxPQUFPO29DQUFFOEIsT0FBTztnQ0FBc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPdkY7R0FwV2dCM0Y7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvU2NhdHRlclBsb3QudHN4PzE5YTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGF0YVBvaW50LCBDbHVzdGVySW5mbyB9IGZyb20gJ0BzaGFyZWQvc2NoZW1hJztcbmltcG9ydCB7IFVzZXIsIE1hcFBpbiwgU2hvcHBpbmdCYWcgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuXG5pbnRlcmZhY2UgU2NhdHRlclBsb3RQcm9wcyB7XG4gIGRhdGFQb2ludHM6IERhdGFQb2ludFtdO1xuICBjbHVzdGVyczogQ2x1c3RlckluZm9bXTtcbiAgY29ubmVjdGlvbnM6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+O1xuICBkYXRhc2V0VHlwZTogJ21lZGljYWwnIHwgJ2NyaW1lJyB8ICdjdXN0b21lcic7XG4gIHhMYWJlbDogc3RyaW5nO1xuICB5TGFiZWw6IHN0cmluZztcbiAgeFJhbmdlPzogW251bWJlciwgbnVtYmVyXTtcbiAgeVJhbmdlPzogW251bWJlciwgbnVtYmVyXTtcbiAgb25BZGRQb2ludD86ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gdm9pZDtcbiAgb25Qb2ludEhvdmVyPzogKHBvaW50OiBEYXRhUG9pbnQgfCBudWxsKSA9PiB2b2lkO1xuICBvbkNsdXN0ZXJIb3Zlcj86IChjbHVzdGVyOiBDbHVzdGVySW5mbyB8IG51bGwpID0+IHZvaWQ7XG4gIGFkZE1vZGU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTY2F0dGVyUGxvdCh7XG4gIGRhdGFQb2ludHMsXG4gIGNsdXN0ZXJzLFxuICBjb25uZWN0aW9ucyxcbiAgZGF0YXNldFR5cGUsXG4gIHhMYWJlbCxcbiAgeUxhYmVsLFxuICBvbkFkZFBvaW50LFxuICBvblBvaW50SG92ZXIsXG4gIG9uQ2x1c3RlckhvdmVyLFxuICBhZGRNb2RlLFxufTogU2NhdHRlclBsb3RQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbaG92ZXJlZFBvaW50LCBzZXRIb3ZlcmVkUG9pbnRdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtob3ZlcmVkQ2x1c3Rlciwgc2V0SG92ZXJlZENsdXN0ZXJdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IHVzZVN0YXRlKHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAgfSk7XG4gIGNvbnN0IFttb3VzZVBvcywgc2V0TW91c2VQb3NdID0gdXNlU3RhdGUoeyB4OiAwLCB5OiAwIH0pO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB7IHRvcDogNDAsIHJpZ2h0OiA0MCwgYm90dG9tOiA2MCwgbGVmdDogNzAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNldERpbWVuc2lvbnMoeyB3aWR0aCwgaGVpZ2h0OiBNYXRoLm1heCg1MDAsIHdpZHRoICogMC43NSkgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGdldFNjYWxlcyA9ICgpID0+IHtcbiAgICBjb25zdCB4VmFsdWVzID0gZGF0YVBvaW50cy5tYXAocCA9PiBwLngpO1xuICAgIGNvbnN0IHlWYWx1ZXMgPSBkYXRhUG9pbnRzLm1hcChwID0+IHAueSk7XG5cbiAgICBjb25zdCB4TWluID0gTWF0aC5taW4oLi4ueFZhbHVlcyk7XG4gICAgY29uc3QgeE1heCA9IE1hdGgubWF4KC4uLnhWYWx1ZXMpO1xuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbiguLi55VmFsdWVzKTtcbiAgICBjb25zdCB5TWF4ID0gTWF0aC5tYXgoLi4ueVZhbHVlcyk7XG5cbiAgICBjb25zdCB4UmFuZ2UgPSB4TWF4IC0geE1pbiB8fCAxO1xuICAgIGNvbnN0IHlSYW5nZSA9IHlNYXggLSB5TWluIHx8IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeE1pbjogeE1pbiAtIHhSYW5nZSAqIDAuMSxcbiAgICAgIHhNYXg6IHhNYXggKyB4UmFuZ2UgKiAwLjEsXG4gICAgICB5TWluOiB5TWluIC0geVJhbmdlICogMC4xLFxuICAgICAgeU1heDogeU1heCArIHlSYW5nZSAqIDAuMSxcbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IHNjYWxlWCA9ICh4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBzY2FsZXMgPSBnZXRTY2FsZXMoKTtcbiAgICByZXR1cm4gcGFkZGluZy5sZWZ0ICsgKCh4IC0gc2NhbGVzLnhNaW4pIC8gKHNjYWxlcy54TWF4IC0gc2NhbGVzLnhNaW4pKSAqIChkaW1lbnNpb25zLndpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodCk7XG4gIH07XG5cbiAgY29uc3Qgc2NhbGVZID0gKHk6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHNjYWxlcyA9IGdldFNjYWxlcygpO1xuICAgIHJldHVybiBkaW1lbnNpb25zLmhlaWdodCAtIHBhZGRpbmcuYm90dG9tIC0gKCh5IC0gc2NhbGVzLnlNaW4pIC8gKHNjYWxlcy55TWF4IC0gc2NhbGVzLnlNaW4pKSAqIChkaW1lbnNpb25zLmhlaWdodCAtIHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20pO1xuICB9O1xuXG4gIGNvbnN0IGludmVyc2VTY2FsZVggPSAocHg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHNjYWxlcyA9IGdldFNjYWxlcygpO1xuICAgIHJldHVybiBzY2FsZXMueE1pbiArICgocHggLSBwYWRkaW5nLmxlZnQpIC8gKGRpbWVuc2lvbnMud2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0KSkgKiAoc2NhbGVzLnhNYXggLSBzY2FsZXMueE1pbik7XG4gIH07XG5cbiAgY29uc3QgaW52ZXJzZVNjYWxlWSA9IChweDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3Qgc2NhbGVzID0gZ2V0U2NhbGVzKCk7XG4gICAgcmV0dXJuIHNjYWxlcy55TWluICsgKChkaW1lbnNpb25zLmhlaWdodCAtIHBhZGRpbmcuYm90dG9tIC0gcHgpIC8gKGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSkpICogKHNjYWxlcy55TWF4IC0gc2NhbGVzLnlNaW4pO1xuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY3R4KSByZXR1cm47XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIGNhbnZhcy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogZHByO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2RpbWVuc2lvbnMud2lkdGh9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtkaW1lbnNpb25zLmhlaWdodH1weGA7XG4gICAgY3R4LnNjYWxlKGRwciwgZHByKTtcblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgLy8gRHJhdyBncmlkXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2hzbCh2YXIoLS1ib3JkZXIpKSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxMDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gcGFkZGluZy5sZWZ0ICsgKGkgLyAxMCkgKiAoZGltZW5zaW9ucy53aWR0aCAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQpO1xuICAgICAgY29uc3QgeSA9IHBhZGRpbmcudG9wICsgKGkgLyAxMCkgKiAoZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCBwYWRkaW5nLnRvcCk7XG4gICAgICBjdHgubGluZVRvKHgsIGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20pO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHBhZGRpbmcubGVmdCwgeSk7XG4gICAgICBjdHgubGluZVRvKGRpbWVuc2lvbnMud2lkdGggLSBwYWRkaW5nLnJpZ2h0LCB5KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgLy8gRHJhdyBjbHVzdGVyc1xuICAgIGNsdXN0ZXJzLmZvckVhY2goKGNsdXN0ZXIsIGlkeCkgPT4ge1xuICAgICAgaWYgKGNsdXN0ZXIucG9pbnRJbmRpY2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBwb2ludHMgPSBjbHVzdGVyLnBvaW50SW5kaWNlcy5tYXAoaSA9PiBkYXRhUG9pbnRzW2ldKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCB4cyA9IHBvaW50cy5tYXAocCA9PiBzY2FsZVgocC54KSk7XG4gICAgICBjb25zdCB5cyA9IHBvaW50cy5tYXAocCA9PiBzY2FsZVkocC55KSk7XG5cbiAgICAgIGNvbnN0IGNlbnRlclggPSB4cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHhzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSB5cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHlzLmxlbmd0aDtcblxuICAgICAgY29uc3QgbWF4RGlzdCA9IE1hdGgubWF4KFxuICAgICAgICAuLi54cy5tYXAoKHgsIGkpID0+IE1hdGguc3FydCgoeCAtIGNlbnRlclgpICoqIDIgKyAoeXNbaV0gLSBjZW50ZXJZKSAqKiAyKSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJhZGl1cyA9IG1heERpc3QgKyAzMDtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsdXN0ZXIuY29sb3IucmVwbGFjZSgnaHNsJywgJ2hzbGEnKS5yZXBsYWNlKCcpJywgJywgMC4wOCknKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNsdXN0ZXIuY29sb3I7XG4gICAgICBjdHgubGluZVdpZHRoID0gMztcblxuICAgICAgaWYgKGhvdmVyZWRDbHVzdGVyID09PSBpZHgpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsdXN0ZXIuY29sb3IucmVwbGFjZSgnaHNsJywgJ2hzbGEnKS5yZXBsYWNlKCcpJywgJywgMC4xNSknKTtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gY2x1c3Rlci5jb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxNTtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICB9KTtcblxuICAgIC8vIERyYXcgY29ubmVjdGlvbnNcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnaHNsKHZhcigtLXByaW1hcnkpKSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMC42O1xuICAgIGN0eC5zZXRMaW5lRGFzaChbNCwgNF0pO1xuXG4gICAgY29ubmVjdGlvbnMuZm9yRWFjaCgoW2ksIGpdKSA9PiB7XG4gICAgICBjb25zdCBwMSA9IGRhdGFQb2ludHNbaV07XG4gICAgICBjb25zdCBwMiA9IGRhdGFQb2ludHNbal07XG4gICAgICBpZiAoIXAxIHx8ICFwMikgcmV0dXJuO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHNjYWxlWChwMS54KSwgc2NhbGVZKHAxLnkpKTtcbiAgICAgIGN0eC5saW5lVG8oc2NhbGVYKHAyLngpLCBzY2FsZVkocDIueSkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgLy8gRHJhdyBheGVzXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2hzbCh2YXIoLS1mb3JlZ3JvdW5kKSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8ocGFkZGluZy5sZWZ0LCBwYWRkaW5nLnRvcCk7XG4gICAgY3R4LmxpbmVUbyhwYWRkaW5nLmxlZnQsIGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20pO1xuICAgIGN0eC5saW5lVG8oZGltZW5zaW9ucy53aWR0aCAtIHBhZGRpbmcucmlnaHQsIGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20pO1xuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIC8vIERyYXcgYXhpcyBsYWJlbHNcbiAgICBjdHguZmlsbFN0eWxlID0gJ2hzbCh2YXIoLS1mb3JlZ3JvdW5kKSknO1xuICAgIGN0eC5mb250ID0gJzE0cHggSW50ZXInO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHguZmlsbFRleHQoeExhYmVsLCBkaW1lbnNpb25zLndpZHRoIC8gMiwgZGltZW5zaW9ucy5oZWlnaHQgLSAyMCk7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUoMjAsIGRpbWVuc2lvbnMuaGVpZ2h0IC8gMik7XG4gICAgY3R4LnJvdGF0ZSgtTWF0aC5QSSAvIDIpO1xuICAgIGN0eC5maWxsVGV4dCh5TGFiZWwsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgfSwgW2RhdGFQb2ludHMsIGNsdXN0ZXJzLCBjb25uZWN0aW9ucywgZGltZW5zaW9ucywgeExhYmVsLCB5TGFiZWwsIGhvdmVyZWRDbHVzdGVyXSk7XG5cbiAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lclJlZi5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIXJlY3QpIHJldHVybjtcblxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgc2V0TW91c2VQb3MoeyB4LCB5IH0pO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGhvdmVyZWQgcG9pbnRzXG4gICAgbGV0IGZvdW5kUG9pbnQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHB4ID0gc2NhbGVYKGRhdGFQb2ludHNbaV0ueCk7XG4gICAgICBjb25zdCBweSA9IHNjYWxlWShkYXRhUG9pbnRzW2ldLnkpO1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCgocHggLSB4KSAqKiAyICsgKHB5IC0geSkgKiogMik7XG5cbiAgICAgIGlmIChkaXN0IDwgMTUpIHtcbiAgICAgICAgc2V0SG92ZXJlZFBvaW50KGkpO1xuICAgICAgICBvblBvaW50SG92ZXI/LihkYXRhUG9pbnRzW2ldKTtcbiAgICAgICAgZm91bmRQb2ludCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm91bmRQb2ludCkge1xuICAgICAgc2V0SG92ZXJlZFBvaW50KG51bGwpO1xuICAgICAgb25Qb2ludEhvdmVyPy4obnVsbCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGhvdmVyZWQgY2x1c3RlcnNcbiAgICBsZXQgZm91bmRDbHVzdGVyID0gZmFsc2U7XG4gICAgY2x1c3RlcnMuZm9yRWFjaCgoY2x1c3RlciwgaWR4KSA9PiB7XG4gICAgICBpZiAoY2x1c3Rlci5wb2ludEluZGljZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHBvaW50cyA9IGNsdXN0ZXIucG9pbnRJbmRpY2VzLm1hcChpID0+IGRhdGFQb2ludHNbaV0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHhzID0gcG9pbnRzLm1hcChwID0+IHNjYWxlWChwLngpKTtcbiAgICAgIGNvbnN0IHlzID0gcG9pbnRzLm1hcChwID0+IHNjYWxlWShwLnkpKTtcblxuICAgICAgY29uc3QgY2VudGVyWCA9IHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8geHMubGVuZ3RoO1xuICAgICAgY29uc3QgY2VudGVyWSA9IHlzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8geXMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBtYXhEaXN0ID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnhzLm1hcCgoeCwgaSkgPT4gTWF0aC5zcXJ0KCh4IC0gY2VudGVyWCkgKiogMiArICh5c1tpXSAtIGNlbnRlclkpICoqIDIpKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmFkaXVzID0gbWF4RGlzdCArIDMwO1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCgoY2VudGVyWCAtIHgpICoqIDIgKyAoY2VudGVyWSAtIHkpICoqIDIpO1xuXG4gICAgICBpZiAoZGlzdCA8IHJhZGl1cyAmJiAhZm91bmRQb2ludCkge1xuICAgICAgICBzZXRIb3ZlcmVkQ2x1c3RlcihpZHgpO1xuICAgICAgICBvbkNsdXN0ZXJIb3Zlcj8uKGNsdXN0ZXIpO1xuICAgICAgICBmb3VuZENsdXN0ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFmb3VuZENsdXN0ZXIpIHtcbiAgICAgIHNldEhvdmVyZWRDbHVzdGVyKG51bGwpO1xuICAgICAgaWYgKCFmb3VuZFBvaW50KSBvbkNsdXN0ZXJIb3Zlcj8uKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVDbGljayA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGlmICghYWRkTW9kZSB8fCAhb25BZGRQb2ludCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lclJlZi5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIXJlY3QpIHJldHVybjtcblxuICAgIGNvbnN0IGNsaWNrWCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICBjb25zdCBjbGlja1kgPSBlLmNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgIC8vIENoZWNrIGlmIGNsaWNrZWQgd2l0aGluIHBsb3QgYXJlYVxuICAgIGlmIChcbiAgICAgIGNsaWNrWCA+PSBwYWRkaW5nLmxlZnQgJiZcbiAgICAgIGNsaWNrWCA8PSBkaW1lbnNpb25zLndpZHRoIC0gcGFkZGluZy5yaWdodCAmJlxuICAgICAgY2xpY2tZID49IHBhZGRpbmcudG9wICYmXG4gICAgICBjbGlja1kgPD0gZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nLmJvdHRvbVxuICAgICkge1xuICAgICAgY29uc3QgZGF0YVggPSBpbnZlcnNlU2NhbGVYKGNsaWNrWCk7XG4gICAgICBjb25zdCBkYXRhWSA9IGludmVyc2VTY2FsZVkoY2xpY2tZKTtcbiAgICAgIG9uQWRkUG9pbnQoZGF0YVgsIGRhdGFZKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgSWNvbkNvbXBvbmVudCA9IGRhdGFzZXRUeXBlID09PSAnbWVkaWNhbCcgPyBVc2VyIDogZGF0YXNldFR5cGUgPT09ICdjcmltZScgPyBNYXBQaW4gOiBTaG9wcGluZ0JhZztcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxuICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmUgdy1mdWxsIGJnLWNhcmQgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLWNhcmQtYm9yZGVyIG92ZXJmbG93LXZpc2libGVcIlxuICAgICAgb25Nb3VzZU1vdmU9e2hhbmRsZU1vdXNlTW92ZX1cbiAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4ge1xuICAgICAgICBzZXRIb3ZlcmVkUG9pbnQobnVsbCk7XG4gICAgICAgIHNldEhvdmVyZWRDbHVzdGVyKG51bGwpO1xuICAgICAgICBvblBvaW50SG92ZXI/LihudWxsKTtcbiAgICAgICAgb25DbHVzdGVySG92ZXI/LihudWxsKTtcbiAgICAgIH19XG4gICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgIHN0eWxlPXt7IGN1cnNvcjogYWRkTW9kZSA/ICdjcm9zc2hhaXInIDogJ2RlZmF1bHQnIH19XG4gICAgPlxuICAgICAgPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gY2xhc3NOYW1lPVwidy1mdWxsXCIgLz5cblxuICAgICAgey8qIFNWRyBvdmVybGF5IGZvciBpY29ucyAqL31cbiAgICAgIDxzdmdcbiAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHBvaW50ZXItZXZlbnRzLW5vbmVcIlxuICAgICAgICB3aWR0aD17ZGltZW5zaW9ucy53aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtkaW1lbnNpb25zLmhlaWdodH1cbiAgICAgICAgc3R5bGU9e3sgb3ZlcmZsb3c6ICd2aXNpYmxlJyB9fVxuICAgICAgPlxuICAgICAgICB7ZGF0YVBvaW50cy5tYXAoKHBvaW50LCBpZHgpID0+IHtcbiAgICAgICAgICBjb25zdCB4ID0gc2NhbGVYKHBvaW50LngpO1xuICAgICAgICAgIGNvbnN0IHkgPSBzY2FsZVkocG9pbnQueSk7XG4gICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gaG92ZXJlZFBvaW50ID09PSBpZHg7XG4gICAgICAgICAgY29uc3QgY2x1c3RlciA9IGNsdXN0ZXJzLmZpbmQoYyA9PiBjLnBvaW50SW5kaWNlcy5pbmNsdWRlcyhpZHgpKTtcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZyBrZXk9e3BvaW50LmlkfSB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4fSwgJHt5fSlgfT5cbiAgICAgICAgICAgICAge2lzSG92ZXJlZCAmJiAoXG4gICAgICAgICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgICAgICAgcj17MTh9XG4gICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICBzdHJva2U9XCJoc2wodmFyKC0tcHJpbWFyeSkpXCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICAgICAgICAgICAgb3BhY2l0eT17MC41fVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYW5pbWF0ZS1wdWxzZVwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAge3BvaW50LmlzTmV3ICYmIChcbiAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICByPXsyMH1cbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImhzbCh2YXIoLS1jaGFydC01KSlcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezN9XG4gICAgICAgICAgICAgICAgICBvcGFjaXR5PXswLjd9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhbmltYXRlLXB1bHNlXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8Zm9yZWlnbk9iamVjdCB4PXstMTJ9IHk9ey0xMn0gd2lkdGg9ezI0fSBoZWlnaHQ9ezI0fT5cbiAgICAgICAgICAgICAgICA8SWNvbkNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdy02IGgtNiB0cmFuc2l0aW9uLWFsbCAke2lzSG92ZXJlZCA/ICdzY2FsZS0xMjUnIDogJyd9YH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjbHVzdGVyID8gY2x1c3Rlci5jb2xvciA6ICdoc2wodmFyKC0tZm9yZWdyb3VuZCkpJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBpc0hvdmVyZWQgPyAnZHJvcC1zaGFkb3coMCAwIDRweCBjdXJyZW50Q29sb3IpJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9mb3JlaWduT2JqZWN0PlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuXG4gICAgICAgIHsvKiBHaG9zdCBpY29uIGZvciBhZGQgbW9kZSAqL31cbiAgICAgICAge2FkZE1vZGUgJiYgbW91c2VQb3MueCA+IHBhZGRpbmcubGVmdCAmJiBtb3VzZVBvcy54IDwgZGltZW5zaW9ucy53aWR0aCAtIHBhZGRpbmcucmlnaHQgJiZcbiAgICAgICAgICBtb3VzZVBvcy55ID4gcGFkZGluZy50b3AgJiYgbW91c2VQb3MueSA8IGRpbWVuc2lvbnMuaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20gJiYgKFxuICAgICAgICAgIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21vdXNlUG9zLnh9LCAke21vdXNlUG9zLnl9KWB9IG9wYWNpdHk9ezAuNX0+XG4gICAgICAgICAgICA8Zm9yZWlnbk9iamVjdCB4PXstMTJ9IHk9ey0xMn0gd2lkdGg9ezI0fSBoZWlnaHQ9ezI0fT5cbiAgICAgICAgICAgICAgPEljb25Db21wb25lbnQgY2xhc3NOYW1lPVwidy02IGgtNlwiIHN0eWxlPXt7IGNvbG9yOiAnaHNsKHZhcigtLXByaW1hcnkpKScgfX0gLz5cbiAgICAgICAgICAgIDwvZm9yZWlnbk9iamVjdD5cbiAgICAgICAgICA8L2c+XG4gICAgICAgICl9XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlVzZXIiLCJNYXBQaW4iLCJTaG9wcGluZ0JhZyIsIlNjYXR0ZXJQbG90IiwiZGF0YVBvaW50cyIsImNsdXN0ZXJzIiwiY29ubmVjdGlvbnMiLCJkYXRhc2V0VHlwZSIsInhMYWJlbCIsInlMYWJlbCIsIm9uQWRkUG9pbnQiLCJvblBvaW50SG92ZXIiLCJvbkNsdXN0ZXJIb3ZlciIsImFkZE1vZGUiLCJjYW52YXNSZWYiLCJjb250YWluZXJSZWYiLCJob3ZlcmVkUG9pbnQiLCJzZXRIb3ZlcmVkUG9pbnQiLCJob3ZlcmVkQ2x1c3RlciIsInNldEhvdmVyZWRDbHVzdGVyIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsIm1vdXNlUG9zIiwic2V0TW91c2VQb3MiLCJ4IiwieSIsInBhZGRpbmciLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ1cGRhdGVEaW1lbnNpb25zIiwiY3VycmVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk1hdGgiLCJtYXgiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldFNjYWxlcyIsInhWYWx1ZXMiLCJtYXAiLCJwIiwieVZhbHVlcyIsInhNaW4iLCJtaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJ4UmFuZ2UiLCJ5UmFuZ2UiLCJzY2FsZVgiLCJzY2FsZXMiLCJzY2FsZVkiLCJpbnZlcnNlU2NhbGVYIiwicHgiLCJpbnZlcnNlU2NhbGVZIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJzdHlsZSIsInNjYWxlIiwiY2xlYXJSZWN0Iiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJnbG9iYWxBbHBoYSIsImkiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJmb3JFYWNoIiwiY2x1c3RlciIsImlkeCIsInBvaW50SW5kaWNlcyIsImxlbmd0aCIsInBvaW50cyIsImZpbHRlciIsIkJvb2xlYW4iLCJ4cyIsInlzIiwiY2VudGVyWCIsInJlZHVjZSIsImEiLCJiIiwiY2VudGVyWSIsIm1heERpc3QiLCJzcXJ0IiwicmFkaXVzIiwiZmlsbFN0eWxlIiwiY29sb3IiLCJyZXBsYWNlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwiYXJjIiwiUEkiLCJmaWxsIiwic2V0TGluZURhc2giLCJqIiwicDEiLCJwMiIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJyZXN0b3JlIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsInJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsImZvdW5kUG9pbnQiLCJweSIsImRpc3QiLCJmb3VuZENsdXN0ZXIiLCJoYW5kbGVDbGljayIsImNsaWNrWCIsImNsaWNrWSIsImRhdGFYIiwiZGF0YVkiLCJJY29uQ29tcG9uZW50IiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJvbkNsaWNrIiwiY3Vyc29yIiwic3ZnIiwib3ZlcmZsb3ciLCJwb2ludCIsImlzSG92ZXJlZCIsImZpbmQiLCJjIiwiaW5jbHVkZXMiLCJnIiwidHJhbnNmb3JtIiwiY2lyY2xlIiwiciIsInN0cm9rZVdpZHRoIiwib3BhY2l0eSIsImlzTmV3IiwiZm9yZWlnbk9iamVjdCIsImlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/ScatterPlot.tsx\n"));

/***/ })

});